// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.5
// source: vpn_service.proto

package vpnapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VPNService_GetStatus_FullMethodName                = "/awg.vpn.v1.VPNService/GetStatus"
	VPNService_Shutdown_FullMethodName                 = "/awg.vpn.v1.VPNService/Shutdown"
	VPNService_Activate_FullMethodName                 = "/awg.vpn.v1.VPNService/Activate"
	VPNService_Deactivate_FullMethodName               = "/awg.vpn.v1.VPNService/Deactivate"
	VPNService_ListTunnels_FullMethodName              = "/awg.vpn.v1.VPNService/ListTunnels"
	VPNService_GetTunnel_FullMethodName                = "/awg.vpn.v1.VPNService/GetTunnel"
	VPNService_AddTunnel_FullMethodName                = "/awg.vpn.v1.VPNService/AddTunnel"
	VPNService_RemoveTunnel_FullMethodName             = "/awg.vpn.v1.VPNService/RemoveTunnel"
	VPNService_UpdateTunnel_FullMethodName             = "/awg.vpn.v1.VPNService/UpdateTunnel"
	VPNService_Connect_FullMethodName                  = "/awg.vpn.v1.VPNService/Connect"
	VPNService_Disconnect_FullMethodName               = "/awg.vpn.v1.VPNService/Disconnect"
	VPNService_RestartTunnel_FullMethodName            = "/awg.vpn.v1.VPNService/RestartTunnel"
	VPNService_SaveTunnelOrder_FullMethodName          = "/awg.vpn.v1.VPNService/SaveTunnelOrder"
	VPNService_RenameTunnel_FullMethodName             = "/awg.vpn.v1.VPNService/RenameTunnel"
	VPNService_ListRules_FullMethodName                = "/awg.vpn.v1.VPNService/ListRules"
	VPNService_SaveRules_FullMethodName                = "/awg.vpn.v1.VPNService/SaveRules"
	VPNService_ListDomainRules_FullMethodName          = "/awg.vpn.v1.VPNService/ListDomainRules"
	VPNService_SaveDomainRules_FullMethodName          = "/awg.vpn.v1.VPNService/SaveDomainRules"
	VPNService_ListGeositeCategories_FullMethodName    = "/awg.vpn.v1.VPNService/ListGeositeCategories"
	VPNService_ListGeoIPCategories_FullMethodName      = "/awg.vpn.v1.VPNService/ListGeoIPCategories"
	VPNService_UpdateGeosite_FullMethodName            = "/awg.vpn.v1.VPNService/UpdateGeosite"
	VPNService_GetConfig_FullMethodName                = "/awg.vpn.v1.VPNService/GetConfig"
	VPNService_SaveConfig_FullMethodName               = "/awg.vpn.v1.VPNService/SaveConfig"
	VPNService_StreamLogs_FullMethodName               = "/awg.vpn.v1.VPNService/StreamLogs"
	VPNService_StreamStats_FullMethodName              = "/awg.vpn.v1.VPNService/StreamStats"
	VPNService_ListProcesses_FullMethodName            = "/awg.vpn.v1.VPNService/ListProcesses"
	VPNService_GetAutostart_FullMethodName             = "/awg.vpn.v1.VPNService/GetAutostart"
	VPNService_SetAutostart_FullMethodName             = "/awg.vpn.v1.VPNService/SetAutostart"
	VPNService_ListSubscriptions_FullMethodName        = "/awg.vpn.v1.VPNService/ListSubscriptions"
	VPNService_AddSubscription_FullMethodName          = "/awg.vpn.v1.VPNService/AddSubscription"
	VPNService_RemoveSubscription_FullMethodName       = "/awg.vpn.v1.VPNService/RemoveSubscription"
	VPNService_RefreshSubscription_FullMethodName      = "/awg.vpn.v1.VPNService/RefreshSubscription"
	VPNService_UpdateSubscription_FullMethodName       = "/awg.vpn.v1.VPNService/UpdateSubscription"
	VPNService_RestoreConnections_FullMethodName       = "/awg.vpn.v1.VPNService/RestoreConnections"
	VPNService_FlushDNS_FullMethodName                 = "/awg.vpn.v1.VPNService/FlushDNS"
	VPNService_CheckUpdate_FullMethodName              = "/awg.vpn.v1.VPNService/CheckUpdate"
	VPNService_ApplyUpdate_FullMethodName              = "/awg.vpn.v1.VPNService/ApplyUpdate"
	VPNService_CheckConflictingServices_FullMethodName = "/awg.vpn.v1.VPNService/CheckConflictingServices"
	VPNService_StopConflictingServices_FullMethodName  = "/awg.vpn.v1.VPNService/StopConflictingServices"
	VPNService_GetDPIEnabled_FullMethodName            = "/awg.vpn.v1.VPNService/GetDPIEnabled"
	VPNService_SetDPIEnabled_FullMethodName            = "/awg.vpn.v1.VPNService/SetDPIEnabled"
	VPNService_ListDPIStrategies_FullMethodName        = "/awg.vpn.v1.VPNService/ListDPIStrategies"
	VPNService_FetchDPIStrategies_FullMethodName       = "/awg.vpn.v1.VPNService/FetchDPIStrategies"
	VPNService_SelectDPIStrategy_FullMethodName        = "/awg.vpn.v1.VPNService/SelectDPIStrategy"
	VPNService_StartDPISearch_FullMethodName           = "/awg.vpn.v1.VPNService/StartDPISearch"
	VPNService_StopDPISearch_FullMethodName            = "/awg.vpn.v1.VPNService/StopDPISearch"
	VPNService_StreamDPISearchProgress_FullMethodName  = "/awg.vpn.v1.VPNService/StreamDPISearchProgress"
	VPNService_ProbeDPI_FullMethodName                 = "/awg.vpn.v1.VPNService/ProbeDPI"
)

// VPNServiceClient is the client API for VPNService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VPNServiceClient interface {
	// -- Service lifecycle --
	GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServiceStatus, error)
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// -- Daemon lifecycle (macOS socket activation) --
	Activate(ctx context.Context, in *ActivateRequest, opts ...grpc.CallOption) (*ActivateResponse, error)
	Deactivate(ctx context.Context, in *DeactivateRequest, opts ...grpc.CallOption) (*DeactivateResponse, error)
	// -- Tunnel management --
	ListTunnels(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TunnelListResponse, error)
	GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*TunnelStatus, error)
	AddTunnel(ctx context.Context, in *AddTunnelRequest, opts ...grpc.CallOption) (*AddTunnelResponse, error)
	RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error)
	UpdateTunnel(ctx context.Context, in *UpdateTunnelRequest, opts ...grpc.CallOption) (*UpdateTunnelResponse, error)
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	RestartTunnel(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	SaveTunnelOrder(ctx context.Context, in *SaveTunnelOrderRequest, opts ...grpc.CallOption) (*SaveTunnelOrderResponse, error)
	RenameTunnel(ctx context.Context, in *RenameTunnelRequest, opts ...grpc.CallOption) (*RenameTunnelResponse, error)
	// -- Rules --
	ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleListResponse, error)
	SaveRules(ctx context.Context, in *SaveRulesRequest, opts ...grpc.CallOption) (*SaveRulesResponse, error)
	// -- Domain rules --
	ListDomainRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DomainRuleListResponse, error)
	SaveDomainRules(ctx context.Context, in *SaveDomainRulesRequest, opts ...grpc.CallOption) (*SaveDomainRulesResponse, error)
	ListGeositeCategories(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GeositeCategoriesResponse, error)
	ListGeoIPCategories(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GeositeCategoriesResponse, error)
	UpdateGeosite(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UpdateGeositeResponse, error)
	// -- Config --
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AppConfig, error)
	SaveConfig(ctx context.Context, in *SaveConfigRequest, opts ...grpc.CallOption) (*SaveConfigResponse, error)
	// -- Streaming --
	StreamLogs(ctx context.Context, in *LogStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
	StreamStats(ctx context.Context, in *StatsStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatsSnapshot], error)
	// -- Processes --
	ListProcesses(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error)
	// -- Autostart --
	GetAutostart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AutostartConfig, error)
	SetAutostart(ctx context.Context, in *SetAutostartRequest, opts ...grpc.CallOption) (*SetAutostartResponse, error)
	// -- Subscriptions --
	ListSubscriptions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SubscriptionListResponse, error)
	AddSubscription(ctx context.Context, in *AddSubscriptionRequest, opts ...grpc.CallOption) (*AddSubscriptionResponse, error)
	RemoveSubscription(ctx context.Context, in *RemoveSubscriptionRequest, opts ...grpc.CallOption) (*RemoveSubscriptionResponse, error)
	RefreshSubscription(ctx context.Context, in *RefreshSubscriptionRequest, opts ...grpc.CallOption) (*RefreshSubscriptionResponse, error)
	UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*UpdateSubscriptionResponse, error)
	// -- Connection restore --
	RestoreConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error)
	// -- DNS --
	FlushDNS(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error)
	// -- Updates --
	CheckUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CheckUpdateResponse, error)
	ApplyUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyUpdateResponse, error)
	// -- Conflicting services --
	CheckConflictingServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConflictingServicesResponse, error)
	StopConflictingServices(ctx context.Context, in *StopConflictingServicesRequest, opts ...grpc.CallOption) (*StopConflictingServicesResponse, error)
	// -- DPI Bypass --
	GetDPIEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetDPIEnabledResponse, error)
	SetDPIEnabled(ctx context.Context, in *SetDPIEnabledRequest, opts ...grpc.CallOption) (*SetDPIEnabledResponse, error)
	ListDPIStrategies(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListDPIStrategiesResponse, error)
	FetchDPIStrategies(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FetchDPIStrategiesResponse, error)
	SelectDPIStrategy(ctx context.Context, in *SelectDPIStrategyRequest, opts ...grpc.CallOption) (*SelectDPIStrategyResponse, error)
	StartDPISearch(ctx context.Context, in *StartDPISearchRequest, opts ...grpc.CallOption) (*StartDPISearchResponse, error)
	StopDPISearch(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StopDPISearchResponse, error)
	StreamDPISearchProgress(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DPISearchProgress], error)
	ProbeDPI(ctx context.Context, in *DPIProbeRequest, opts ...grpc.CallOption) (*DPIProbeResponse, error)
}

type vPNServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVPNServiceClient(cc grpc.ClientConnInterface) VPNServiceClient {
	return &vPNServiceClient{cc}
}

func (c *vPNServiceClient) GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServiceStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceStatus)
	err := c.cc.Invoke(ctx, VPNService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VPNService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Activate(ctx context.Context, in *ActivateRequest, opts ...grpc.CallOption) (*ActivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivateResponse)
	err := c.cc.Invoke(ctx, VPNService_Activate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Deactivate(ctx context.Context, in *DeactivateRequest, opts ...grpc.CallOption) (*DeactivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeactivateResponse)
	err := c.cc.Invoke(ctx, VPNService_Deactivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListTunnels(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TunnelListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TunnelListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListTunnels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*TunnelStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TunnelStatus)
	err := c.cc.Invoke(ctx, VPNService_GetTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) AddTunnel(ctx context.Context, in *AddTunnelRequest, opts ...grpc.CallOption) (*AddTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_AddTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_RemoveTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) UpdateTunnel(ctx context.Context, in *UpdateTunnelRequest, opts ...grpc.CallOption) (*UpdateTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_UpdateTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_Connect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectResponse)
	err := c.cc.Invoke(ctx, VPNService_Disconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RestartTunnel(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_RestartTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveTunnelOrder(ctx context.Context, in *SaveTunnelOrderRequest, opts ...grpc.CallOption) (*SaveTunnelOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveTunnelOrderResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveTunnelOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RenameTunnel(ctx context.Context, in *RenameTunnelRequest, opts ...grpc.CallOption) (*RenameTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenameTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_RenameTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveRules(ctx context.Context, in *SaveRulesRequest, opts ...grpc.CallOption) (*SaveRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveRulesResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListDomainRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DomainRuleListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DomainRuleListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListDomainRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveDomainRules(ctx context.Context, in *SaveDomainRulesRequest, opts ...grpc.CallOption) (*SaveDomainRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveDomainRulesResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveDomainRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListGeositeCategories(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GeositeCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeositeCategoriesResponse)
	err := c.cc.Invoke(ctx, VPNService_ListGeositeCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListGeoIPCategories(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GeositeCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeositeCategoriesResponse)
	err := c.cc.Invoke(ctx, VPNService_ListGeoIPCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) UpdateGeosite(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UpdateGeositeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGeositeResponse)
	err := c.cc.Invoke(ctx, VPNService_UpdateGeosite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AppConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppConfig)
	err := c.cc.Invoke(ctx, VPNService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveConfig(ctx context.Context, in *SaveConfigRequest, opts ...grpc.CallOption) (*SaveConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveConfigResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StreamLogs(ctx context.Context, in *LogStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VPNService_ServiceDesc.Streams[0], VPNService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogStreamRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamLogsClient = grpc.ServerStreamingClient[LogEntry]

func (c *vPNServiceClient) StreamStats(ctx context.Context, in *StatsStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatsSnapshot], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VPNService_ServiceDesc.Streams[1], VPNService_StreamStats_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StatsStreamRequest, StatsSnapshot]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamStatsClient = grpc.ServerStreamingClient[StatsSnapshot]

func (c *vPNServiceClient) ListProcesses(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListProcesses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetAutostart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AutostartConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AutostartConfig)
	err := c.cc.Invoke(ctx, VPNService_GetAutostart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SetAutostart(ctx context.Context, in *SetAutostartRequest, opts ...grpc.CallOption) (*SetAutostartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAutostartResponse)
	err := c.cc.Invoke(ctx, VPNService_SetAutostart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListSubscriptions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SubscriptionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscriptionListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListSubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) AddSubscription(ctx context.Context, in *AddSubscriptionRequest, opts ...grpc.CallOption) (*AddSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddSubscriptionResponse)
	err := c.cc.Invoke(ctx, VPNService_AddSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RemoveSubscription(ctx context.Context, in *RemoveSubscriptionRequest, opts ...grpc.CallOption) (*RemoveSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveSubscriptionResponse)
	err := c.cc.Invoke(ctx, VPNService_RemoveSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RefreshSubscription(ctx context.Context, in *RefreshSubscriptionRequest, opts ...grpc.CallOption) (*RefreshSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshSubscriptionResponse)
	err := c.cc.Invoke(ctx, VPNService_RefreshSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*UpdateSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSubscriptionResponse)
	err := c.cc.Invoke(ctx, VPNService_UpdateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RestoreConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_RestoreConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) FlushDNS(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_FlushDNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) CheckUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CheckUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUpdateResponse)
	err := c.cc.Invoke(ctx, VPNService_CheckUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ApplyUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ApplyUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyUpdateResponse)
	err := c.cc.Invoke(ctx, VPNService_ApplyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) CheckConflictingServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConflictingServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConflictingServicesResponse)
	err := c.cc.Invoke(ctx, VPNService_CheckConflictingServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StopConflictingServices(ctx context.Context, in *StopConflictingServicesRequest, opts ...grpc.CallOption) (*StopConflictingServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopConflictingServicesResponse)
	err := c.cc.Invoke(ctx, VPNService_StopConflictingServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetDPIEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetDPIEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDPIEnabledResponse)
	err := c.cc.Invoke(ctx, VPNService_GetDPIEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SetDPIEnabled(ctx context.Context, in *SetDPIEnabledRequest, opts ...grpc.CallOption) (*SetDPIEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDPIEnabledResponse)
	err := c.cc.Invoke(ctx, VPNService_SetDPIEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListDPIStrategies(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListDPIStrategiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDPIStrategiesResponse)
	err := c.cc.Invoke(ctx, VPNService_ListDPIStrategies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) FetchDPIStrategies(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FetchDPIStrategiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchDPIStrategiesResponse)
	err := c.cc.Invoke(ctx, VPNService_FetchDPIStrategies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SelectDPIStrategy(ctx context.Context, in *SelectDPIStrategyRequest, opts ...grpc.CallOption) (*SelectDPIStrategyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SelectDPIStrategyResponse)
	err := c.cc.Invoke(ctx, VPNService_SelectDPIStrategy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StartDPISearch(ctx context.Context, in *StartDPISearchRequest, opts ...grpc.CallOption) (*StartDPISearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartDPISearchResponse)
	err := c.cc.Invoke(ctx, VPNService_StartDPISearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StopDPISearch(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StopDPISearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopDPISearchResponse)
	err := c.cc.Invoke(ctx, VPNService_StopDPISearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StreamDPISearchProgress(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DPISearchProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VPNService_ServiceDesc.Streams[2], VPNService_StreamDPISearchProgress_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, DPISearchProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamDPISearchProgressClient = grpc.ServerStreamingClient[DPISearchProgress]

func (c *vPNServiceClient) ProbeDPI(ctx context.Context, in *DPIProbeRequest, opts ...grpc.CallOption) (*DPIProbeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DPIProbeResponse)
	err := c.cc.Invoke(ctx, VPNService_ProbeDPI_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VPNServiceServer is the server API for VPNService service.
// All implementations must embed UnimplementedVPNServiceServer
// for forward compatibility.
type VPNServiceServer interface {
	// -- Service lifecycle --
	GetStatus(context.Context, *emptypb.Empty) (*ServiceStatus, error)
	Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// -- Daemon lifecycle (macOS socket activation) --
	Activate(context.Context, *ActivateRequest) (*ActivateResponse, error)
	Deactivate(context.Context, *DeactivateRequest) (*DeactivateResponse, error)
	// -- Tunnel management --
	ListTunnels(context.Context, *emptypb.Empty) (*TunnelListResponse, error)
	GetTunnel(context.Context, *GetTunnelRequest) (*TunnelStatus, error)
	AddTunnel(context.Context, *AddTunnelRequest) (*AddTunnelResponse, error)
	RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error)
	UpdateTunnel(context.Context, *UpdateTunnelRequest) (*UpdateTunnelResponse, error)
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	RestartTunnel(context.Context, *ConnectRequest) (*ConnectResponse, error)
	SaveTunnelOrder(context.Context, *SaveTunnelOrderRequest) (*SaveTunnelOrderResponse, error)
	RenameTunnel(context.Context, *RenameTunnelRequest) (*RenameTunnelResponse, error)
	// -- Rules --
	ListRules(context.Context, *emptypb.Empty) (*RuleListResponse, error)
	SaveRules(context.Context, *SaveRulesRequest) (*SaveRulesResponse, error)
	// -- Domain rules --
	ListDomainRules(context.Context, *emptypb.Empty) (*DomainRuleListResponse, error)
	SaveDomainRules(context.Context, *SaveDomainRulesRequest) (*SaveDomainRulesResponse, error)
	ListGeositeCategories(context.Context, *emptypb.Empty) (*GeositeCategoriesResponse, error)
	ListGeoIPCategories(context.Context, *emptypb.Empty) (*GeositeCategoriesResponse, error)
	UpdateGeosite(context.Context, *emptypb.Empty) (*UpdateGeositeResponse, error)
	// -- Config --
	GetConfig(context.Context, *emptypb.Empty) (*AppConfig, error)
	SaveConfig(context.Context, *SaveConfigRequest) (*SaveConfigResponse, error)
	// -- Streaming --
	StreamLogs(*LogStreamRequest, grpc.ServerStreamingServer[LogEntry]) error
	StreamStats(*StatsStreamRequest, grpc.ServerStreamingServer[StatsSnapshot]) error
	// -- Processes --
	ListProcesses(context.Context, *ProcessListRequest) (*ProcessListResponse, error)
	// -- Autostart --
	GetAutostart(context.Context, *emptypb.Empty) (*AutostartConfig, error)
	SetAutostart(context.Context, *SetAutostartRequest) (*SetAutostartResponse, error)
	// -- Subscriptions --
	ListSubscriptions(context.Context, *emptypb.Empty) (*SubscriptionListResponse, error)
	AddSubscription(context.Context, *AddSubscriptionRequest) (*AddSubscriptionResponse, error)
	RemoveSubscription(context.Context, *RemoveSubscriptionRequest) (*RemoveSubscriptionResponse, error)
	RefreshSubscription(context.Context, *RefreshSubscriptionRequest) (*RefreshSubscriptionResponse, error)
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*UpdateSubscriptionResponse, error)
	// -- Connection restore --
	RestoreConnections(context.Context, *emptypb.Empty) (*ConnectResponse, error)
	// -- DNS --
	FlushDNS(context.Context, *emptypb.Empty) (*ConnectResponse, error)
	// -- Updates --
	CheckUpdate(context.Context, *emptypb.Empty) (*CheckUpdateResponse, error)
	ApplyUpdate(context.Context, *emptypb.Empty) (*ApplyUpdateResponse, error)
	// -- Conflicting services --
	CheckConflictingServices(context.Context, *emptypb.Empty) (*ConflictingServicesResponse, error)
	StopConflictingServices(context.Context, *StopConflictingServicesRequest) (*StopConflictingServicesResponse, error)
	// -- DPI Bypass --
	GetDPIEnabled(context.Context, *emptypb.Empty) (*GetDPIEnabledResponse, error)
	SetDPIEnabled(context.Context, *SetDPIEnabledRequest) (*SetDPIEnabledResponse, error)
	ListDPIStrategies(context.Context, *emptypb.Empty) (*ListDPIStrategiesResponse, error)
	FetchDPIStrategies(context.Context, *emptypb.Empty) (*FetchDPIStrategiesResponse, error)
	SelectDPIStrategy(context.Context, *SelectDPIStrategyRequest) (*SelectDPIStrategyResponse, error)
	StartDPISearch(context.Context, *StartDPISearchRequest) (*StartDPISearchResponse, error)
	StopDPISearch(context.Context, *emptypb.Empty) (*StopDPISearchResponse, error)
	StreamDPISearchProgress(*emptypb.Empty, grpc.ServerStreamingServer[DPISearchProgress]) error
	ProbeDPI(context.Context, *DPIProbeRequest) (*DPIProbeResponse, error)
	mustEmbedUnimplementedVPNServiceServer()
}

// UnimplementedVPNServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVPNServiceServer struct{}

func (UnimplementedVPNServiceServer) GetStatus(context.Context, *emptypb.Empty) (*ServiceStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedVPNServiceServer) Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedVPNServiceServer) Activate(context.Context, *ActivateRequest) (*ActivateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Activate not implemented")
}
func (UnimplementedVPNServiceServer) Deactivate(context.Context, *DeactivateRequest) (*DeactivateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Deactivate not implemented")
}
func (UnimplementedVPNServiceServer) ListTunnels(context.Context, *emptypb.Empty) (*TunnelListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTunnels not implemented")
}
func (UnimplementedVPNServiceServer) GetTunnel(context.Context, *GetTunnelRequest) (*TunnelStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTunnel not implemented")
}
func (UnimplementedVPNServiceServer) AddTunnel(context.Context, *AddTunnelRequest) (*AddTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddTunnel not implemented")
}
func (UnimplementedVPNServiceServer) RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveTunnel not implemented")
}
func (UnimplementedVPNServiceServer) UpdateTunnel(context.Context, *UpdateTunnelRequest) (*UpdateTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTunnel not implemented")
}
func (UnimplementedVPNServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedVPNServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedVPNServiceServer) RestartTunnel(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartTunnel not implemented")
}
func (UnimplementedVPNServiceServer) SaveTunnelOrder(context.Context, *SaveTunnelOrderRequest) (*SaveTunnelOrderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveTunnelOrder not implemented")
}
func (UnimplementedVPNServiceServer) RenameTunnel(context.Context, *RenameTunnelRequest) (*RenameTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenameTunnel not implemented")
}
func (UnimplementedVPNServiceServer) ListRules(context.Context, *emptypb.Empty) (*RuleListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedVPNServiceServer) SaveRules(context.Context, *SaveRulesRequest) (*SaveRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveRules not implemented")
}
func (UnimplementedVPNServiceServer) ListDomainRules(context.Context, *emptypb.Empty) (*DomainRuleListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDomainRules not implemented")
}
func (UnimplementedVPNServiceServer) SaveDomainRules(context.Context, *SaveDomainRulesRequest) (*SaveDomainRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveDomainRules not implemented")
}
func (UnimplementedVPNServiceServer) ListGeositeCategories(context.Context, *emptypb.Empty) (*GeositeCategoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGeositeCategories not implemented")
}
func (UnimplementedVPNServiceServer) ListGeoIPCategories(context.Context, *emptypb.Empty) (*GeositeCategoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGeoIPCategories not implemented")
}
func (UnimplementedVPNServiceServer) UpdateGeosite(context.Context, *emptypb.Empty) (*UpdateGeositeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGeosite not implemented")
}
func (UnimplementedVPNServiceServer) GetConfig(context.Context, *emptypb.Empty) (*AppConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedVPNServiceServer) SaveConfig(context.Context, *SaveConfigRequest) (*SaveConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedVPNServiceServer) StreamLogs(*LogStreamRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedVPNServiceServer) StreamStats(*StatsStreamRequest, grpc.ServerStreamingServer[StatsSnapshot]) error {
	return status.Error(codes.Unimplemented, "method StreamStats not implemented")
}
func (UnimplementedVPNServiceServer) ListProcesses(context.Context, *ProcessListRequest) (*ProcessListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProcesses not implemented")
}
func (UnimplementedVPNServiceServer) GetAutostart(context.Context, *emptypb.Empty) (*AutostartConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAutostart not implemented")
}
func (UnimplementedVPNServiceServer) SetAutostart(context.Context, *SetAutostartRequest) (*SetAutostartResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetAutostart not implemented")
}
func (UnimplementedVPNServiceServer) ListSubscriptions(context.Context, *emptypb.Empty) (*SubscriptionListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSubscriptions not implemented")
}
func (UnimplementedVPNServiceServer) AddSubscription(context.Context, *AddSubscriptionRequest) (*AddSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddSubscription not implemented")
}
func (UnimplementedVPNServiceServer) RemoveSubscription(context.Context, *RemoveSubscriptionRequest) (*RemoveSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveSubscription not implemented")
}
func (UnimplementedVPNServiceServer) RefreshSubscription(context.Context, *RefreshSubscriptionRequest) (*RefreshSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshSubscription not implemented")
}
func (UnimplementedVPNServiceServer) UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*UpdateSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedVPNServiceServer) RestoreConnections(context.Context, *emptypb.Empty) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreConnections not implemented")
}
func (UnimplementedVPNServiceServer) FlushDNS(context.Context, *emptypb.Empty) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FlushDNS not implemented")
}
func (UnimplementedVPNServiceServer) CheckUpdate(context.Context, *emptypb.Empty) (*CheckUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckUpdate not implemented")
}
func (UnimplementedVPNServiceServer) ApplyUpdate(context.Context, *emptypb.Empty) (*ApplyUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyUpdate not implemented")
}
func (UnimplementedVPNServiceServer) CheckConflictingServices(context.Context, *emptypb.Empty) (*ConflictingServicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckConflictingServices not implemented")
}
func (UnimplementedVPNServiceServer) StopConflictingServices(context.Context, *StopConflictingServicesRequest) (*StopConflictingServicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopConflictingServices not implemented")
}
func (UnimplementedVPNServiceServer) GetDPIEnabled(context.Context, *emptypb.Empty) (*GetDPIEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDPIEnabled not implemented")
}
func (UnimplementedVPNServiceServer) SetDPIEnabled(context.Context, *SetDPIEnabledRequest) (*SetDPIEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDPIEnabled not implemented")
}
func (UnimplementedVPNServiceServer) ListDPIStrategies(context.Context, *emptypb.Empty) (*ListDPIStrategiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDPIStrategies not implemented")
}
func (UnimplementedVPNServiceServer) FetchDPIStrategies(context.Context, *emptypb.Empty) (*FetchDPIStrategiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchDPIStrategies not implemented")
}
func (UnimplementedVPNServiceServer) SelectDPIStrategy(context.Context, *SelectDPIStrategyRequest) (*SelectDPIStrategyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SelectDPIStrategy not implemented")
}
func (UnimplementedVPNServiceServer) StartDPISearch(context.Context, *StartDPISearchRequest) (*StartDPISearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartDPISearch not implemented")
}
func (UnimplementedVPNServiceServer) StopDPISearch(context.Context, *emptypb.Empty) (*StopDPISearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopDPISearch not implemented")
}
func (UnimplementedVPNServiceServer) StreamDPISearchProgress(*emptypb.Empty, grpc.ServerStreamingServer[DPISearchProgress]) error {
	return status.Error(codes.Unimplemented, "method StreamDPISearchProgress not implemented")
}
func (UnimplementedVPNServiceServer) ProbeDPI(context.Context, *DPIProbeRequest) (*DPIProbeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ProbeDPI not implemented")
}
func (UnimplementedVPNServiceServer) mustEmbedUnimplementedVPNServiceServer() {}
func (UnimplementedVPNServiceServer) testEmbeddedByValue()                    {}

// UnsafeVPNServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VPNServiceServer will
// result in compilation errors.
type UnsafeVPNServiceServer interface {
	mustEmbedUnimplementedVPNServiceServer()
}

func RegisterVPNServiceServer(s grpc.ServiceRegistrar, srv VPNServiceServer) {
	// If the following call panics, it indicates UnimplementedVPNServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VPNService_ServiceDesc, srv)
}

func _VPNService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Activate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Activate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Activate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Activate(ctx, req.(*ActivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Deactivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Deactivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Deactivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Deactivate(ctx, req.(*DeactivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListTunnels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListTunnels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListTunnels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListTunnels(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetTunnel(ctx, req.(*GetTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_AddTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).AddTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_AddTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).AddTunnel(ctx, req.(*AddTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RemoveTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RemoveTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RemoveTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RemoveTunnel(ctx, req.(*RemoveTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_UpdateTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).UpdateTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_UpdateTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).UpdateTunnel(ctx, req.(*UpdateTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Disconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RestartTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RestartTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RestartTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RestartTunnel(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveTunnelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveTunnelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveTunnelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveTunnelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveTunnelOrder(ctx, req.(*SaveTunnelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RenameTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RenameTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RenameTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RenameTunnel(ctx, req.(*RenameTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListRules(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveRules(ctx, req.(*SaveRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListDomainRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListDomainRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListDomainRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListDomainRules(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveDomainRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveDomainRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveDomainRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveDomainRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveDomainRules(ctx, req.(*SaveDomainRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListGeositeCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListGeositeCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListGeositeCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListGeositeCategories(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListGeoIPCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListGeoIPCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListGeoIPCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListGeoIPCategories(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_UpdateGeosite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).UpdateGeosite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_UpdateGeosite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).UpdateGeosite(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveConfig(ctx, req.(*SaveConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VPNServiceServer).StreamLogs(m, &grpc.GenericServerStream[LogStreamRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamLogsServer = grpc.ServerStreamingServer[LogEntry]

func _VPNService_StreamStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VPNServiceServer).StreamStats(m, &grpc.GenericServerStream[StatsStreamRequest, StatsSnapshot]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamStatsServer = grpc.ServerStreamingServer[StatsSnapshot]

func _VPNService_ListProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListProcesses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListProcesses(ctx, req.(*ProcessListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetAutostart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetAutostart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetAutostart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetAutostart(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SetAutostart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutostartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SetAutostart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SetAutostart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SetAutostart(ctx, req.(*SetAutostartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListSubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListSubscriptions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_AddSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).AddSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_AddSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).AddSubscription(ctx, req.(*AddSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RemoveSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RemoveSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RemoveSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RemoveSubscription(ctx, req.(*RemoveSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RefreshSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RefreshSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RefreshSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RefreshSubscription(ctx, req.(*RefreshSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_UpdateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RestoreConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RestoreConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RestoreConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RestoreConnections(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_FlushDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).FlushDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_FlushDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).FlushDNS(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_CheckUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).CheckUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_CheckUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).CheckUpdate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ApplyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ApplyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ApplyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ApplyUpdate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_CheckConflictingServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).CheckConflictingServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_CheckConflictingServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).CheckConflictingServices(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StopConflictingServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopConflictingServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).StopConflictingServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_StopConflictingServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).StopConflictingServices(ctx, req.(*StopConflictingServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetDPIEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetDPIEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetDPIEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetDPIEnabled(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SetDPIEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDPIEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SetDPIEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SetDPIEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SetDPIEnabled(ctx, req.(*SetDPIEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListDPIStrategies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListDPIStrategies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListDPIStrategies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListDPIStrategies(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_FetchDPIStrategies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).FetchDPIStrategies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_FetchDPIStrategies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).FetchDPIStrategies(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SelectDPIStrategy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectDPIStrategyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SelectDPIStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SelectDPIStrategy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SelectDPIStrategy(ctx, req.(*SelectDPIStrategyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StartDPISearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDPISearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).StartDPISearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_StartDPISearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).StartDPISearch(ctx, req.(*StartDPISearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StopDPISearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).StopDPISearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_StopDPISearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).StopDPISearch(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StreamDPISearchProgress_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VPNServiceServer).StreamDPISearchProgress(m, &grpc.GenericServerStream[emptypb.Empty, DPISearchProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamDPISearchProgressServer = grpc.ServerStreamingServer[DPISearchProgress]

func _VPNService_ProbeDPI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DPIProbeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ProbeDPI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ProbeDPI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ProbeDPI(ctx, req.(*DPIProbeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VPNService_ServiceDesc is the grpc.ServiceDesc for VPNService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VPNService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "awg.vpn.v1.VPNService",
	HandlerType: (*VPNServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _VPNService_GetStatus_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _VPNService_Shutdown_Handler,
		},
		{
			MethodName: "Activate",
			Handler:    _VPNService_Activate_Handler,
		},
		{
			MethodName: "Deactivate",
			Handler:    _VPNService_Deactivate_Handler,
		},
		{
			MethodName: "ListTunnels",
			Handler:    _VPNService_ListTunnels_Handler,
		},
		{
			MethodName: "GetTunnel",
			Handler:    _VPNService_GetTunnel_Handler,
		},
		{
			MethodName: "AddTunnel",
			Handler:    _VPNService_AddTunnel_Handler,
		},
		{
			MethodName: "RemoveTunnel",
			Handler:    _VPNService_RemoveTunnel_Handler,
		},
		{
			MethodName: "UpdateTunnel",
			Handler:    _VPNService_UpdateTunnel_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _VPNService_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _VPNService_Disconnect_Handler,
		},
		{
			MethodName: "RestartTunnel",
			Handler:    _VPNService_RestartTunnel_Handler,
		},
		{
			MethodName: "SaveTunnelOrder",
			Handler:    _VPNService_SaveTunnelOrder_Handler,
		},
		{
			MethodName: "RenameTunnel",
			Handler:    _VPNService_RenameTunnel_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _VPNService_ListRules_Handler,
		},
		{
			MethodName: "SaveRules",
			Handler:    _VPNService_SaveRules_Handler,
		},
		{
			MethodName: "ListDomainRules",
			Handler:    _VPNService_ListDomainRules_Handler,
		},
		{
			MethodName: "SaveDomainRules",
			Handler:    _VPNService_SaveDomainRules_Handler,
		},
		{
			MethodName: "ListGeositeCategories",
			Handler:    _VPNService_ListGeositeCategories_Handler,
		},
		{
			MethodName: "ListGeoIPCategories",
			Handler:    _VPNService_ListGeoIPCategories_Handler,
		},
		{
			MethodName: "UpdateGeosite",
			Handler:    _VPNService_UpdateGeosite_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _VPNService_GetConfig_Handler,
		},
		{
			MethodName: "SaveConfig",
			Handler:    _VPNService_SaveConfig_Handler,
		},
		{
			MethodName: "ListProcesses",
			Handler:    _VPNService_ListProcesses_Handler,
		},
		{
			MethodName: "GetAutostart",
			Handler:    _VPNService_GetAutostart_Handler,
		},
		{
			MethodName: "SetAutostart",
			Handler:    _VPNService_SetAutostart_Handler,
		},
		{
			MethodName: "ListSubscriptions",
			Handler:    _VPNService_ListSubscriptions_Handler,
		},
		{
			MethodName: "AddSubscription",
			Handler:    _VPNService_AddSubscription_Handler,
		},
		{
			MethodName: "RemoveSubscription",
			Handler:    _VPNService_RemoveSubscription_Handler,
		},
		{
			MethodName: "RefreshSubscription",
			Handler:    _VPNService_RefreshSubscription_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _VPNService_UpdateSubscription_Handler,
		},
		{
			MethodName: "RestoreConnections",
			Handler:    _VPNService_RestoreConnections_Handler,
		},
		{
			MethodName: "FlushDNS",
			Handler:    _VPNService_FlushDNS_Handler,
		},
		{
			MethodName: "CheckUpdate",
			Handler:    _VPNService_CheckUpdate_Handler,
		},
		{
			MethodName: "ApplyUpdate",
			Handler:    _VPNService_ApplyUpdate_Handler,
		},
		{
			MethodName: "CheckConflictingServices",
			Handler:    _VPNService_CheckConflictingServices_Handler,
		},
		{
			MethodName: "StopConflictingServices",
			Handler:    _VPNService_StopConflictingServices_Handler,
		},
		{
			MethodName: "GetDPIEnabled",
			Handler:    _VPNService_GetDPIEnabled_Handler,
		},
		{
			MethodName: "SetDPIEnabled",
			Handler:    _VPNService_SetDPIEnabled_Handler,
		},
		{
			MethodName: "ListDPIStrategies",
			Handler:    _VPNService_ListDPIStrategies_Handler,
		},
		{
			MethodName: "FetchDPIStrategies",
			Handler:    _VPNService_FetchDPIStrategies_Handler,
		},
		{
			MethodName: "SelectDPIStrategy",
			Handler:    _VPNService_SelectDPIStrategy_Handler,
		},
		{
			MethodName: "StartDPISearch",
			Handler:    _VPNService_StartDPISearch_Handler,
		},
		{
			MethodName: "StopDPISearch",
			Handler:    _VPNService_StopDPISearch_Handler,
		},
		{
			MethodName: "ProbeDPI",
			Handler:    _VPNService_ProbeDPI_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _VPNService_StreamLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamStats",
			Handler:       _VPNService_StreamStats_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamDPISearchProgress",
			Handler:       _VPNService_StreamDPISearchProgress_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vpn_service.proto",
}
