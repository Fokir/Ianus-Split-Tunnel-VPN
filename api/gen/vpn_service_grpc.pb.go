// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.5
// source: vpn_service.proto

package vpnapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VPNService_GetStatus_FullMethodName          = "/awg.vpn.v1.VPNService/GetStatus"
	VPNService_Shutdown_FullMethodName           = "/awg.vpn.v1.VPNService/Shutdown"
	VPNService_ListTunnels_FullMethodName        = "/awg.vpn.v1.VPNService/ListTunnels"
	VPNService_GetTunnel_FullMethodName          = "/awg.vpn.v1.VPNService/GetTunnel"
	VPNService_AddTunnel_FullMethodName          = "/awg.vpn.v1.VPNService/AddTunnel"
	VPNService_RemoveTunnel_FullMethodName       = "/awg.vpn.v1.VPNService/RemoveTunnel"
	VPNService_UpdateTunnel_FullMethodName       = "/awg.vpn.v1.VPNService/UpdateTunnel"
	VPNService_Connect_FullMethodName            = "/awg.vpn.v1.VPNService/Connect"
	VPNService_Disconnect_FullMethodName         = "/awg.vpn.v1.VPNService/Disconnect"
	VPNService_RestartTunnel_FullMethodName      = "/awg.vpn.v1.VPNService/RestartTunnel"
	VPNService_ListRules_FullMethodName          = "/awg.vpn.v1.VPNService/ListRules"
	VPNService_SaveRules_FullMethodName          = "/awg.vpn.v1.VPNService/SaveRules"
	VPNService_GetConfig_FullMethodName          = "/awg.vpn.v1.VPNService/GetConfig"
	VPNService_SaveConfig_FullMethodName         = "/awg.vpn.v1.VPNService/SaveConfig"
	VPNService_StreamLogs_FullMethodName         = "/awg.vpn.v1.VPNService/StreamLogs"
	VPNService_StreamStats_FullMethodName        = "/awg.vpn.v1.VPNService/StreamStats"
	VPNService_ListProcesses_FullMethodName      = "/awg.vpn.v1.VPNService/ListProcesses"
	VPNService_GetAutostart_FullMethodName       = "/awg.vpn.v1.VPNService/GetAutostart"
	VPNService_SetAutostart_FullMethodName       = "/awg.vpn.v1.VPNService/SetAutostart"
	VPNService_RestoreConnections_FullMethodName = "/awg.vpn.v1.VPNService/RestoreConnections"
)

// VPNServiceClient is the client API for VPNService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VPNServiceClient interface {
	// -- Service lifecycle --
	GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServiceStatus, error)
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// -- Tunnel management --
	ListTunnels(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TunnelListResponse, error)
	GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*TunnelStatus, error)
	AddTunnel(ctx context.Context, in *AddTunnelRequest, opts ...grpc.CallOption) (*AddTunnelResponse, error)
	RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error)
	UpdateTunnel(ctx context.Context, in *UpdateTunnelRequest, opts ...grpc.CallOption) (*UpdateTunnelResponse, error)
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	RestartTunnel(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// -- Rules --
	ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleListResponse, error)
	SaveRules(ctx context.Context, in *SaveRulesRequest, opts ...grpc.CallOption) (*SaveRulesResponse, error)
	// -- Config --
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AppConfig, error)
	SaveConfig(ctx context.Context, in *SaveConfigRequest, opts ...grpc.CallOption) (*SaveConfigResponse, error)
	// -- Streaming --
	StreamLogs(ctx context.Context, in *LogStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
	StreamStats(ctx context.Context, in *StatsStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatsSnapshot], error)
	// -- Processes --
	ListProcesses(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error)
	// -- Autostart --
	GetAutostart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AutostartConfig, error)
	SetAutostart(ctx context.Context, in *SetAutostartRequest, opts ...grpc.CallOption) (*SetAutostartResponse, error)
	// -- Connection restore --
	RestoreConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error)
}

type vPNServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVPNServiceClient(cc grpc.ClientConnInterface) VPNServiceClient {
	return &vPNServiceClient{cc}
}

func (c *vPNServiceClient) GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServiceStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceStatus)
	err := c.cc.Invoke(ctx, VPNService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VPNService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListTunnels(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TunnelListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TunnelListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListTunnels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*TunnelStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TunnelStatus)
	err := c.cc.Invoke(ctx, VPNService_GetTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) AddTunnel(ctx context.Context, in *AddTunnelRequest, opts ...grpc.CallOption) (*AddTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_AddTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_RemoveTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) UpdateTunnel(ctx context.Context, in *UpdateTunnelRequest, opts ...grpc.CallOption) (*UpdateTunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTunnelResponse)
	err := c.cc.Invoke(ctx, VPNService_UpdateTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_Connect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectResponse)
	err := c.cc.Invoke(ctx, VPNService_Disconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RestartTunnel(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_RestartTunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveRules(ctx context.Context, in *SaveRulesRequest, opts ...grpc.CallOption) (*SaveRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveRulesResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AppConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppConfig)
	err := c.cc.Invoke(ctx, VPNService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SaveConfig(ctx context.Context, in *SaveConfigRequest, opts ...grpc.CallOption) (*SaveConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveConfigResponse)
	err := c.cc.Invoke(ctx, VPNService_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) StreamLogs(ctx context.Context, in *LogStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VPNService_ServiceDesc.Streams[0], VPNService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogStreamRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamLogsClient = grpc.ServerStreamingClient[LogEntry]

func (c *vPNServiceClient) StreamStats(ctx context.Context, in *StatsStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatsSnapshot], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VPNService_ServiceDesc.Streams[1], VPNService_StreamStats_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StatsStreamRequest, StatsSnapshot]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamStatsClient = grpc.ServerStreamingClient[StatsSnapshot]

func (c *vPNServiceClient) ListProcesses(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessListResponse)
	err := c.cc.Invoke(ctx, VPNService_ListProcesses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) GetAutostart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AutostartConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AutostartConfig)
	err := c.cc.Invoke(ctx, VPNService_GetAutostart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) SetAutostart(ctx context.Context, in *SetAutostartRequest, opts ...grpc.CallOption) (*SetAutostartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAutostartResponse)
	err := c.cc.Invoke(ctx, VPNService_SetAutostart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPNServiceClient) RestoreConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, VPNService_RestoreConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VPNServiceServer is the server API for VPNService service.
// All implementations must embed UnimplementedVPNServiceServer
// for forward compatibility.
type VPNServiceServer interface {
	// -- Service lifecycle --
	GetStatus(context.Context, *emptypb.Empty) (*ServiceStatus, error)
	Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// -- Tunnel management --
	ListTunnels(context.Context, *emptypb.Empty) (*TunnelListResponse, error)
	GetTunnel(context.Context, *GetTunnelRequest) (*TunnelStatus, error)
	AddTunnel(context.Context, *AddTunnelRequest) (*AddTunnelResponse, error)
	RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error)
	UpdateTunnel(context.Context, *UpdateTunnelRequest) (*UpdateTunnelResponse, error)
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	RestartTunnel(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// -- Rules --
	ListRules(context.Context, *emptypb.Empty) (*RuleListResponse, error)
	SaveRules(context.Context, *SaveRulesRequest) (*SaveRulesResponse, error)
	// -- Config --
	GetConfig(context.Context, *emptypb.Empty) (*AppConfig, error)
	SaveConfig(context.Context, *SaveConfigRequest) (*SaveConfigResponse, error)
	// -- Streaming --
	StreamLogs(*LogStreamRequest, grpc.ServerStreamingServer[LogEntry]) error
	StreamStats(*StatsStreamRequest, grpc.ServerStreamingServer[StatsSnapshot]) error
	// -- Processes --
	ListProcesses(context.Context, *ProcessListRequest) (*ProcessListResponse, error)
	// -- Autostart --
	GetAutostart(context.Context, *emptypb.Empty) (*AutostartConfig, error)
	SetAutostart(context.Context, *SetAutostartRequest) (*SetAutostartResponse, error)
	// -- Connection restore --
	RestoreConnections(context.Context, *emptypb.Empty) (*ConnectResponse, error)
	mustEmbedUnimplementedVPNServiceServer()
}

// UnimplementedVPNServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVPNServiceServer struct{}

func (UnimplementedVPNServiceServer) GetStatus(context.Context, *emptypb.Empty) (*ServiceStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedVPNServiceServer) Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedVPNServiceServer) ListTunnels(context.Context, *emptypb.Empty) (*TunnelListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTunnels not implemented")
}
func (UnimplementedVPNServiceServer) GetTunnel(context.Context, *GetTunnelRequest) (*TunnelStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTunnel not implemented")
}
func (UnimplementedVPNServiceServer) AddTunnel(context.Context, *AddTunnelRequest) (*AddTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddTunnel not implemented")
}
func (UnimplementedVPNServiceServer) RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveTunnel not implemented")
}
func (UnimplementedVPNServiceServer) UpdateTunnel(context.Context, *UpdateTunnelRequest) (*UpdateTunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTunnel not implemented")
}
func (UnimplementedVPNServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedVPNServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedVPNServiceServer) RestartTunnel(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartTunnel not implemented")
}
func (UnimplementedVPNServiceServer) ListRules(context.Context, *emptypb.Empty) (*RuleListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedVPNServiceServer) SaveRules(context.Context, *SaveRulesRequest) (*SaveRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveRules not implemented")
}
func (UnimplementedVPNServiceServer) GetConfig(context.Context, *emptypb.Empty) (*AppConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedVPNServiceServer) SaveConfig(context.Context, *SaveConfigRequest) (*SaveConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedVPNServiceServer) StreamLogs(*LogStreamRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedVPNServiceServer) StreamStats(*StatsStreamRequest, grpc.ServerStreamingServer[StatsSnapshot]) error {
	return status.Error(codes.Unimplemented, "method StreamStats not implemented")
}
func (UnimplementedVPNServiceServer) ListProcesses(context.Context, *ProcessListRequest) (*ProcessListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProcesses not implemented")
}
func (UnimplementedVPNServiceServer) GetAutostart(context.Context, *emptypb.Empty) (*AutostartConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAutostart not implemented")
}
func (UnimplementedVPNServiceServer) SetAutostart(context.Context, *SetAutostartRequest) (*SetAutostartResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetAutostart not implemented")
}
func (UnimplementedVPNServiceServer) RestoreConnections(context.Context, *emptypb.Empty) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreConnections not implemented")
}
func (UnimplementedVPNServiceServer) mustEmbedUnimplementedVPNServiceServer() {}
func (UnimplementedVPNServiceServer) testEmbeddedByValue()                    {}

// UnsafeVPNServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VPNServiceServer will
// result in compilation errors.
type UnsafeVPNServiceServer interface {
	mustEmbedUnimplementedVPNServiceServer()
}

func RegisterVPNServiceServer(s grpc.ServiceRegistrar, srv VPNServiceServer) {
	// If the following call panics, it indicates UnimplementedVPNServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VPNService_ServiceDesc, srv)
}

func _VPNService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListTunnels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListTunnels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListTunnels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListTunnels(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetTunnel(ctx, req.(*GetTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_AddTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).AddTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_AddTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).AddTunnel(ctx, req.(*AddTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RemoveTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RemoveTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RemoveTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RemoveTunnel(ctx, req.(*RemoveTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_UpdateTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).UpdateTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_UpdateTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).UpdateTunnel(ctx, req.(*UpdateTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_Disconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RestartTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RestartTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RestartTunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RestartTunnel(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListRules(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveRules(ctx, req.(*SaveRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SaveConfig(ctx, req.(*SaveConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VPNServiceServer).StreamLogs(m, &grpc.GenericServerStream[LogStreamRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamLogsServer = grpc.ServerStreamingServer[LogEntry]

func _VPNService_StreamStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VPNServiceServer).StreamStats(m, &grpc.GenericServerStream[StatsStreamRequest, StatsSnapshot]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VPNService_StreamStatsServer = grpc.ServerStreamingServer[StatsSnapshot]

func _VPNService_ListProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).ListProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_ListProcesses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).ListProcesses(ctx, req.(*ProcessListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_GetAutostart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).GetAutostart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_GetAutostart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).GetAutostart(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_SetAutostart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutostartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).SetAutostart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_SetAutostart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).SetAutostart(ctx, req.(*SetAutostartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPNService_RestoreConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPNServiceServer).RestoreConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VPNService_RestoreConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPNServiceServer).RestoreConnections(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VPNService_ServiceDesc is the grpc.ServiceDesc for VPNService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VPNService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "awg.vpn.v1.VPNService",
	HandlerType: (*VPNServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _VPNService_GetStatus_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _VPNService_Shutdown_Handler,
		},
		{
			MethodName: "ListTunnels",
			Handler:    _VPNService_ListTunnels_Handler,
		},
		{
			MethodName: "GetTunnel",
			Handler:    _VPNService_GetTunnel_Handler,
		},
		{
			MethodName: "AddTunnel",
			Handler:    _VPNService_AddTunnel_Handler,
		},
		{
			MethodName: "RemoveTunnel",
			Handler:    _VPNService_RemoveTunnel_Handler,
		},
		{
			MethodName: "UpdateTunnel",
			Handler:    _VPNService_UpdateTunnel_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _VPNService_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _VPNService_Disconnect_Handler,
		},
		{
			MethodName: "RestartTunnel",
			Handler:    _VPNService_RestartTunnel_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _VPNService_ListRules_Handler,
		},
		{
			MethodName: "SaveRules",
			Handler:    _VPNService_SaveRules_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _VPNService_GetConfig_Handler,
		},
		{
			MethodName: "SaveConfig",
			Handler:    _VPNService_SaveConfig_Handler,
		},
		{
			MethodName: "ListProcesses",
			Handler:    _VPNService_ListProcesses_Handler,
		},
		{
			MethodName: "GetAutostart",
			Handler:    _VPNService_GetAutostart_Handler,
		},
		{
			MethodName: "SetAutostart",
			Handler:    _VPNService_SetAutostart_Handler,
		},
		{
			MethodName: "RestoreConnections",
			Handler:    _VPNService_RestoreConnections_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _VPNService_StreamLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamStats",
			Handler:       _VPNService_StreamStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vpn_service.proto",
}
