// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.5
// source: vpn_service.proto

package vpnapi

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TunnelState int32

const (
	TunnelState_TUNNEL_STATE_DOWN       TunnelState = 0
	TunnelState_TUNNEL_STATE_CONNECTING TunnelState = 1
	TunnelState_TUNNEL_STATE_UP         TunnelState = 2
	TunnelState_TUNNEL_STATE_ERROR      TunnelState = 3
)

// Enum value maps for TunnelState.
var (
	TunnelState_name = map[int32]string{
		0: "TUNNEL_STATE_DOWN",
		1: "TUNNEL_STATE_CONNECTING",
		2: "TUNNEL_STATE_UP",
		3: "TUNNEL_STATE_ERROR",
	}
	TunnelState_value = map[string]int32{
		"TUNNEL_STATE_DOWN":       0,
		"TUNNEL_STATE_CONNECTING": 1,
		"TUNNEL_STATE_UP":         2,
		"TUNNEL_STATE_ERROR":      3,
	}
)

func (x TunnelState) Enum() *TunnelState {
	p := new(TunnelState)
	*p = x
	return p
}

func (x TunnelState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelState) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[0].Descriptor()
}

func (TunnelState) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[0]
}

func (x TunnelState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelState.Descriptor instead.
func (TunnelState) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{0}
}

type FallbackPolicy int32

const (
	FallbackPolicy_FALLBACK_ALLOW_DIRECT FallbackPolicy = 0
	FallbackPolicy_FALLBACK_BLOCK        FallbackPolicy = 1
	FallbackPolicy_FALLBACK_DROP         FallbackPolicy = 2
	FallbackPolicy_FALLBACK_FAILOVER     FallbackPolicy = 3
)

// Enum value maps for FallbackPolicy.
var (
	FallbackPolicy_name = map[int32]string{
		0: "FALLBACK_ALLOW_DIRECT",
		1: "FALLBACK_BLOCK",
		2: "FALLBACK_DROP",
		3: "FALLBACK_FAILOVER",
	}
	FallbackPolicy_value = map[string]int32{
		"FALLBACK_ALLOW_DIRECT": 0,
		"FALLBACK_BLOCK":        1,
		"FALLBACK_DROP":         2,
		"FALLBACK_FAILOVER":     3,
	}
)

func (x FallbackPolicy) Enum() *FallbackPolicy {
	p := new(FallbackPolicy)
	*p = x
	return p
}

func (x FallbackPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FallbackPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[1].Descriptor()
}

func (FallbackPolicy) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[1]
}

func (x FallbackPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FallbackPolicy.Descriptor instead.
func (FallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{1}
}

type LogLevel int32

const (
	LogLevel_LOG_LEVEL_DEBUG LogLevel = 0
	LogLevel_LOG_LEVEL_INFO  LogLevel = 1
	LogLevel_LOG_LEVEL_WARN  LogLevel = 2
	LogLevel_LOG_LEVEL_ERROR LogLevel = 3
	LogLevel_LOG_LEVEL_OFF   LogLevel = 4
)

// Enum value maps for LogLevel.
var (
	LogLevel_name = map[int32]string{
		0: "LOG_LEVEL_DEBUG",
		1: "LOG_LEVEL_INFO",
		2: "LOG_LEVEL_WARN",
		3: "LOG_LEVEL_ERROR",
		4: "LOG_LEVEL_OFF",
	}
	LogLevel_value = map[string]int32{
		"LOG_LEVEL_DEBUG": 0,
		"LOG_LEVEL_INFO":  1,
		"LOG_LEVEL_WARN":  2,
		"LOG_LEVEL_ERROR": 3,
		"LOG_LEVEL_OFF":   4,
	}
)

func (x LogLevel) Enum() *LogLevel {
	p := new(LogLevel)
	*p = x
	return p
}

func (x LogLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[2].Descriptor()
}

func (LogLevel) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[2]
}

func (x LogLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogLevel.Descriptor instead.
func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{2}
}

type DomainAction int32

const (
	DomainAction_DOMAIN_ACTION_ROUTE  DomainAction = 0
	DomainAction_DOMAIN_ACTION_DIRECT DomainAction = 1
	DomainAction_DOMAIN_ACTION_BLOCK  DomainAction = 2
)

// Enum value maps for DomainAction.
var (
	DomainAction_name = map[int32]string{
		0: "DOMAIN_ACTION_ROUTE",
		1: "DOMAIN_ACTION_DIRECT",
		2: "DOMAIN_ACTION_BLOCK",
	}
	DomainAction_value = map[string]int32{
		"DOMAIN_ACTION_ROUTE":  0,
		"DOMAIN_ACTION_DIRECT": 1,
		"DOMAIN_ACTION_BLOCK":  2,
	}
)

func (x DomainAction) Enum() *DomainAction {
	p := new(DomainAction)
	*p = x
	return p
}

func (x DomainAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DomainAction) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[3].Descriptor()
}

func (DomainAction) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[3]
}

func (x DomainAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DomainAction.Descriptor instead.
func (DomainAction) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{3}
}

type TunnelConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Protocol       string                 `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Name           string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Settings       map[string]string      `protobuf:"bytes,4,rep,name=settings,proto3" json:"settings,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AllowedIps     []string               `protobuf:"bytes,5,rep,name=allowed_ips,json=allowedIps,proto3" json:"allowed_ips,omitempty"`
	DisallowedIps  []string               `protobuf:"bytes,6,rep,name=disallowed_ips,json=disallowedIps,proto3" json:"disallowed_ips,omitempty"`
	DisallowedApps []string               `protobuf:"bytes,7,rep,name=disallowed_apps,json=disallowedApps,proto3" json:"disallowed_apps,omitempty"`
	SortIndex      int32                  `protobuf:"varint,8,opt,name=sort_index,json=sortIndex,proto3" json:"sort_index,omitempty"` // user-defined display order
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TunnelConfig) Reset() {
	*x = TunnelConfig{}
	mi := &file_vpn_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelConfig) ProtoMessage() {}

func (x *TunnelConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelConfig.ProtoReflect.Descriptor instead.
func (*TunnelConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{0}
}

func (x *TunnelConfig) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TunnelConfig) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *TunnelConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TunnelConfig) GetSettings() map[string]string {
	if x != nil {
		return x.Settings
	}
	return nil
}

func (x *TunnelConfig) GetAllowedIps() []string {
	if x != nil {
		return x.AllowedIps
	}
	return nil
}

func (x *TunnelConfig) GetDisallowedIps() []string {
	if x != nil {
		return x.DisallowedIps
	}
	return nil
}

func (x *TunnelConfig) GetDisallowedApps() []string {
	if x != nil {
		return x.DisallowedApps
	}
	return nil
}

func (x *TunnelConfig) GetSortIndex() int32 {
	if x != nil {
		return x.SortIndex
	}
	return 0
}

type TunnelStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Config        *TunnelConfig          `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	State         TunnelState            `protobuf:"varint,3,opt,name=state,proto3,enum=awg.vpn.v1.TunnelState" json:"state,omitempty"`
	Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`                                // error message if state == ERROR
	AdapterIp     string                 `protobuf:"bytes,5,opt,name=adapter_ip,json=adapterIp,proto3" json:"adapter_ip,omitempty"`       // VPN adapter IP (e.g. "10.8.1.2")
	ExternalIp    string                 `protobuf:"bytes,6,opt,name=external_ip,json=externalIp,proto3" json:"external_ip,omitempty"`    // VPN server endpoint IP
	CountryCode   string                 `protobuf:"bytes,7,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"` // 2-letter country code from geoip
	SortIndex     int32                  `protobuf:"varint,8,opt,name=sort_index,json=sortIndex,proto3" json:"sort_index,omitempty"`      // user-defined display order
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelStatus) Reset() {
	*x = TunnelStatus{}
	mi := &file_vpn_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelStatus) ProtoMessage() {}

func (x *TunnelStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelStatus.ProtoReflect.Descriptor instead.
func (*TunnelStatus) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{1}
}

func (x *TunnelStatus) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TunnelStatus) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *TunnelStatus) GetState() TunnelState {
	if x != nil {
		return x.State
	}
	return TunnelState_TUNNEL_STATE_DOWN
}

func (x *TunnelStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *TunnelStatus) GetAdapterIp() string {
	if x != nil {
		return x.AdapterIp
	}
	return ""
}

func (x *TunnelStatus) GetExternalIp() string {
	if x != nil {
		return x.ExternalIp
	}
	return ""
}

func (x *TunnelStatus) GetCountryCode() string {
	if x != nil {
		return x.CountryCode
	}
	return ""
}

func (x *TunnelStatus) GetSortIndex() int32 {
	if x != nil {
		return x.SortIndex
	}
	return 0
}

type DomainRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pattern       string                 `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`                   // "domain:vk.com", "full:example.com", "keyword:google", "geosite:ru"
	TunnelId      string                 `protobuf:"bytes,2,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // only for DOMAIN_ACTION_ROUTE
	Action        DomainAction           `protobuf:"varint,3,opt,name=action,proto3,enum=awg.vpn.v1.DomainAction" json:"action,omitempty"`
	Active        bool                   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"` // tunnel is connected (for UI display)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DomainRule) Reset() {
	*x = DomainRule{}
	mi := &file_vpn_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DomainRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DomainRule) ProtoMessage() {}

func (x *DomainRule) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DomainRule.ProtoReflect.Descriptor instead.
func (*DomainRule) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{2}
}

func (x *DomainRule) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *DomainRule) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *DomainRule) GetAction() DomainAction {
	if x != nil {
		return x.Action
	}
	return DomainAction_DOMAIN_ACTION_ROUTE
}

func (x *DomainRule) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

type Rule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pattern       string                 `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	TunnelId      string                 `protobuf:"bytes,2,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // empty for drop-only rules
	Fallback      FallbackPolicy         `protobuf:"varint,3,opt,name=fallback,proto3,enum=awg.vpn.v1.FallbackPolicy" json:"fallback,omitempty"`
	Priority      string                 `protobuf:"bytes,4,opt,name=priority,proto3" json:"priority,omitempty"` // "auto", "realtime", "normal", "low"
	Active        bool                   `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`    // tunnel is connected, rule is active
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Rule) Reset() {
	*x = Rule{}
	mi := &file_vpn_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{3}
}

func (x *Rule) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *Rule) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *Rule) GetFallback() FallbackPolicy {
	if x != nil {
		return x.Fallback
	}
	return FallbackPolicy_FALLBACK_ALLOW_DIRECT
}

func (x *Rule) GetPriority() string {
	if x != nil {
		return x.Priority
	}
	return ""
}

func (x *Rule) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

type DNSCacheConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MaxSize       int32                  `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	MinTtl        string                 `protobuf:"bytes,3,opt,name=min_ttl,json=minTtl,proto3" json:"min_ttl,omitempty"` // duration string, e.g. "30s"
	MaxTtl        string                 `protobuf:"bytes,4,opt,name=max_ttl,json=maxTtl,proto3" json:"max_ttl,omitempty"` // duration string, e.g. "5m"
	NegTtl        string                 `protobuf:"bytes,5,opt,name=neg_ttl,json=negTtl,proto3" json:"neg_ttl,omitempty"` // duration string, e.g. "60s"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSCacheConfig) Reset() {
	*x = DNSCacheConfig{}
	mi := &file_vpn_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSCacheConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSCacheConfig) ProtoMessage() {}

func (x *DNSCacheConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSCacheConfig.ProtoReflect.Descriptor instead.
func (*DNSCacheConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{4}
}

func (x *DNSCacheConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DNSCacheConfig) GetMaxSize() int32 {
	if x != nil {
		return x.MaxSize
	}
	return 0
}

func (x *DNSCacheConfig) GetMinTtl() string {
	if x != nil {
		return x.MinTtl
	}
	return ""
}

func (x *DNSCacheConfig) GetMaxTtl() string {
	if x != nil {
		return x.MaxTtl
	}
	return ""
}

func (x *DNSCacheConfig) GetNegTtl() string {
	if x != nil {
		return x.NegTtl
	}
	return ""
}

type DNSConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // deprecated: use tunnel_ids
	Servers       []string               `protobuf:"bytes,2,rep,name=servers,proto3" json:"servers,omitempty"`
	Cache         *DNSCacheConfig        `protobuf:"bytes,3,opt,name=cache,proto3" json:"cache,omitempty"`
	TunnelIds     []string               `protobuf:"bytes,4,rep,name=tunnel_ids,json=tunnelIds,proto3" json:"tunnel_ids,omitempty"` // tunnels for parallel DNS resolution
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSConfig) Reset() {
	*x = DNSConfig{}
	mi := &file_vpn_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSConfig) ProtoMessage() {}

func (x *DNSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.
func (*DNSConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{5}
}

func (x *DNSConfig) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *DNSConfig) GetServers() []string {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *DNSConfig) GetCache() *DNSCacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

func (x *DNSConfig) GetTunnelIds() []string {
	if x != nil {
		return x.TunnelIds
	}
	return nil
}

type GlobalFilterConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AllowedIps     []string               `protobuf:"bytes,1,rep,name=allowed_ips,json=allowedIps,proto3" json:"allowed_ips,omitempty"`
	DisallowedIps  []string               `protobuf:"bytes,2,rep,name=disallowed_ips,json=disallowedIps,proto3" json:"disallowed_ips,omitempty"`
	DisallowedApps []string               `protobuf:"bytes,3,rep,name=disallowed_apps,json=disallowedApps,proto3" json:"disallowed_apps,omitempty"`
	DisableLocal   bool                   `protobuf:"varint,4,opt,name=disable_local,json=disableLocal,proto3" json:"disable_local,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GlobalFilterConfig) Reset() {
	*x = GlobalFilterConfig{}
	mi := &file_vpn_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobalFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalFilterConfig) ProtoMessage() {}

func (x *GlobalFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalFilterConfig.ProtoReflect.Descriptor instead.
func (*GlobalFilterConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{6}
}

func (x *GlobalFilterConfig) GetAllowedIps() []string {
	if x != nil {
		return x.AllowedIps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisallowedIps() []string {
	if x != nil {
		return x.DisallowedIps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisallowedApps() []string {
	if x != nil {
		return x.DisallowedApps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisableLocal() bool {
	if x != nil {
		return x.DisableLocal
	}
	return false
}

type LogConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Level              string                 `protobuf:"bytes,1,opt,name=level,proto3" json:"level,omitempty"`                                                                                     // "debug", "info", "warn", "error", "off"
	Components         map[string]string      `protobuf:"bytes,2,rep,name=components,proto3" json:"components,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // per-component overrides
	FileLoggingEnabled bool                   `protobuf:"varint,3,opt,name=file_logging_enabled,json=fileLoggingEnabled,proto3" json:"file_logging_enabled,omitempty"`                              // write logs to file (default: true)
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LogConfig) Reset() {
	*x = LogConfig{}
	mi := &file_vpn_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogConfig) ProtoMessage() {}

func (x *LogConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogConfig.ProtoReflect.Descriptor instead.
func (*LogConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{7}
}

func (x *LogConfig) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *LogConfig) GetComponents() map[string]string {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *LogConfig) GetFileLoggingEnabled() bool {
	if x != nil {
		return x.FileLoggingEnabled
	}
	return false
}

type SubscriptionConfig struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Name            string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                              // unique subscription name
	Url             string                 `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`                                                // subscription URL
	RefreshInterval string                 `protobuf:"bytes,3,opt,name=refresh_interval,json=refreshInterval,proto3" json:"refresh_interval,omitempty"` // e.g. "6h", "24h"
	UserAgent       string                 `protobuf:"bytes,4,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`                   // custom User-Agent header
	Prefix          string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`                                          // prefix for generated tunnel IDs
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SubscriptionConfig) Reset() {
	*x = SubscriptionConfig{}
	mi := &file_vpn_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriptionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriptionConfig) ProtoMessage() {}

func (x *SubscriptionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriptionConfig.ProtoReflect.Descriptor instead.
func (*SubscriptionConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{8}
}

func (x *SubscriptionConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SubscriptionConfig) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *SubscriptionConfig) GetRefreshInterval() string {
	if x != nil {
		return x.RefreshInterval
	}
	return ""
}

func (x *SubscriptionConfig) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *SubscriptionConfig) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

type SubscriptionStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *SubscriptionConfig    `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	TunnelCount   int32                  `protobuf:"varint,2,opt,name=tunnel_count,json=tunnelCount,proto3" json:"tunnel_count,omitempty"` // number of tunnels fetched
	LastError     string                 `protobuf:"bytes,3,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`        // last error message (empty if OK)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscriptionStatus) Reset() {
	*x = SubscriptionStatus{}
	mi := &file_vpn_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriptionStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriptionStatus) ProtoMessage() {}

func (x *SubscriptionStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriptionStatus.ProtoReflect.Descriptor instead.
func (*SubscriptionStatus) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{9}
}

func (x *SubscriptionStatus) GetConfig() *SubscriptionConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *SubscriptionStatus) GetTunnelCount() int32 {
	if x != nil {
		return x.TunnelCount
	}
	return 0
}

func (x *SubscriptionStatus) GetLastError() string {
	if x != nil {
		return x.LastError
	}
	return ""
}

type ReconnectConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Interval      string                 `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`                        // duration string, e.g. "5s"
	MaxRetries    int32                  `protobuf:"varint,3,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"` // 0 = unlimited
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReconnectConfig) Reset() {
	*x = ReconnectConfig{}
	mi := &file_vpn_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconnectConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconnectConfig) ProtoMessage() {}

func (x *ReconnectConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconnectConfig.ProtoReflect.Descriptor instead.
func (*ReconnectConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{10}
}

func (x *ReconnectConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ReconnectConfig) GetInterval() string {
	if x != nil {
		return x.Interval
	}
	return ""
}

func (x *ReconnectConfig) GetMaxRetries() int32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

type AppConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Global        *GlobalFilterConfig    `protobuf:"bytes,1,opt,name=global,proto3" json:"global,omitempty"`
	Tunnels       []*TunnelConfig        `protobuf:"bytes,2,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	Rules         []*Rule                `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	Dns           *DNSConfig             `protobuf:"bytes,4,opt,name=dns,proto3" json:"dns,omitempty"`
	Logging       *LogConfig             `protobuf:"bytes,5,opt,name=logging,proto3" json:"logging,omitempty"`
	DomainRules   []*DomainRule          `protobuf:"bytes,6,rep,name=domain_rules,json=domainRules,proto3" json:"domain_rules,omitempty"`
	Subscriptions []*SubscriptionConfig  `protobuf:"bytes,7,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	Reconnect     *ReconnectConfig       `protobuf:"bytes,8,opt,name=reconnect,proto3" json:"reconnect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppConfig) Reset() {
	*x = AppConfig{}
	mi := &file_vpn_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppConfig) ProtoMessage() {}

func (x *AppConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppConfig.ProtoReflect.Descriptor instead.
func (*AppConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{11}
}

func (x *AppConfig) GetGlobal() *GlobalFilterConfig {
	if x != nil {
		return x.Global
	}
	return nil
}

func (x *AppConfig) GetTunnels() []*TunnelConfig {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

func (x *AppConfig) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *AppConfig) GetDns() *DNSConfig {
	if x != nil {
		return x.Dns
	}
	return nil
}

func (x *AppConfig) GetLogging() *LogConfig {
	if x != nil {
		return x.Logging
	}
	return nil
}

func (x *AppConfig) GetDomainRules() []*DomainRule {
	if x != nil {
		return x.DomainRules
	}
	return nil
}

func (x *AppConfig) GetSubscriptions() []*SubscriptionConfig {
	if x != nil {
		return x.Subscriptions
	}
	return nil
}

func (x *AppConfig) GetReconnect() *ReconnectConfig {
	if x != nil {
		return x.Reconnect
	}
	return nil
}

type TunnelStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	State         TunnelState            `protobuf:"varint,2,opt,name=state,proto3,enum=awg.vpn.v1.TunnelState" json:"state,omitempty"`
	BytesTx       int64                  `protobuf:"varint,3,opt,name=bytes_tx,json=bytesTx,proto3" json:"bytes_tx,omitempty"`           // total bytes sent
	BytesRx       int64                  `protobuf:"varint,4,opt,name=bytes_rx,json=bytesRx,proto3" json:"bytes_rx,omitempty"`           // total bytes received
	SpeedTx       int64                  `protobuf:"varint,5,opt,name=speed_tx,json=speedTx,proto3" json:"speed_tx,omitempty"`           // bytes/sec upload
	SpeedRx       int64                  `protobuf:"varint,6,opt,name=speed_rx,json=speedRx,proto3" json:"speed_rx,omitempty"`           // bytes/sec download
	PacketLoss    float64                `protobuf:"fixed64,7,opt,name=packet_loss,json=packetLoss,proto3" json:"packet_loss,omitempty"` // 0.0-1.0, fraction of lost packets
	LatencyMs     int64                  `protobuf:"varint,8,opt,name=latency_ms,json=latencyMs,proto3" json:"latency_ms,omitempty"`     // RTT in milliseconds
	LastHandshake *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_handshake,json=lastHandshake,proto3" json:"last_handshake,omitempty"`
	JitterMs      int64                  `protobuf:"varint,10,opt,name=jitter_ms,json=jitterMs,proto3" json:"jitter_ms,omitempty"` // max-min RTT in milliseconds (1-min window)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelStats) Reset() {
	*x = TunnelStats{}
	mi := &file_vpn_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelStats) ProtoMessage() {}

func (x *TunnelStats) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelStats.ProtoReflect.Descriptor instead.
func (*TunnelStats) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{12}
}

func (x *TunnelStats) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *TunnelStats) GetState() TunnelState {
	if x != nil {
		return x.State
	}
	return TunnelState_TUNNEL_STATE_DOWN
}

func (x *TunnelStats) GetBytesTx() int64 {
	if x != nil {
		return x.BytesTx
	}
	return 0
}

func (x *TunnelStats) GetBytesRx() int64 {
	if x != nil {
		return x.BytesRx
	}
	return 0
}

func (x *TunnelStats) GetSpeedTx() int64 {
	if x != nil {
		return x.SpeedTx
	}
	return 0
}

func (x *TunnelStats) GetSpeedRx() int64 {
	if x != nil {
		return x.SpeedRx
	}
	return 0
}

func (x *TunnelStats) GetPacketLoss() float64 {
	if x != nil {
		return x.PacketLoss
	}
	return 0
}

func (x *TunnelStats) GetLatencyMs() int64 {
	if x != nil {
		return x.LatencyMs
	}
	return 0
}

func (x *TunnelStats) GetLastHandshake() *timestamppb.Timestamp {
	if x != nil {
		return x.LastHandshake
	}
	return nil
}

func (x *TunnelStats) GetJitterMs() int64 {
	if x != nil {
		return x.JitterMs
	}
	return 0
}

type StatsSnapshot struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tunnels       []*TunnelStats         `protobuf:"bytes,1,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsSnapshot) Reset() {
	*x = StatsSnapshot{}
	mi := &file_vpn_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsSnapshot) ProtoMessage() {}

func (x *StatsSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsSnapshot.ProtoReflect.Descriptor instead.
func (*StatsSnapshot) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{13}
}

func (x *StatsSnapshot) GetTunnels() []*TunnelStats {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

func (x *StatsSnapshot) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

type LogEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Level         LogLevel               `protobuf:"varint,2,opt,name=level,proto3,enum=awg.vpn.v1.LogLevel" json:"level,omitempty"`
	Tag           string                 `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"` // "[Core]", "[Gateway]", etc.
	Message       string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogEntry) Reset() {
	*x = LogEntry{}
	mi := &file_vpn_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogEntry) ProtoMessage() {}

func (x *LogEntry) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{14}
}

func (x *LogEntry) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *LogEntry) GetLevel() LogLevel {
	if x != nil {
		return x.Level
	}
	return LogLevel_LOG_LEVEL_DEBUG
}

func (x *LogEntry) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *LogEntry) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ProcessInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pid           uint32                 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"` // exe file name
	Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"` // full exe path
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessInfo) Reset() {
	*x = ProcessInfo{}
	mi := &file_vpn_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessInfo) ProtoMessage() {}

func (x *ProcessInfo) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessInfo.ProtoReflect.Descriptor instead.
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{15}
}

func (x *ProcessInfo) GetPid() uint32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *ProcessInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ProcessInfo) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type ConnectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // specific tunnel, or empty for all
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	mi := &file_vpn_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{16}
}

func (x *ConnectRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type ConnectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectResponse) Reset() {
	*x = ConnectResponse{}
	mi := &file_vpn_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectResponse) ProtoMessage() {}

func (x *ConnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{17}
}

func (x *ConnectResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ConnectResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type DisconnectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // specific tunnel, or empty for all
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectRequest) Reset() {
	*x = DisconnectRequest{}
	mi := &file_vpn_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectRequest) ProtoMessage() {}

func (x *DisconnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectRequest.ProtoReflect.Descriptor instead.
func (*DisconnectRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{18}
}

func (x *DisconnectRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type DisconnectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectResponse) Reset() {
	*x = DisconnectResponse{}
	mi := &file_vpn_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectResponse) ProtoMessage() {}

func (x *DisconnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectResponse.ProtoReflect.Descriptor instead.
func (*DisconnectResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{19}
}

func (x *DisconnectResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DisconnectResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type AddTunnelRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Config         *TunnelConfig          `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	ConfigFileData []byte                 `protobuf:"bytes,2,opt,name=config_file_data,json=configFileData,proto3" json:"config_file_data,omitempty"` // raw .conf file content (for AWG)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AddTunnelRequest) Reset() {
	*x = AddTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddTunnelRequest) ProtoMessage() {}

func (x *AddTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddTunnelRequest.ProtoReflect.Descriptor instead.
func (*AddTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{20}
}

func (x *AddTunnelRequest) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *AddTunnelRequest) GetConfigFileData() []byte {
	if x != nil {
		return x.ConfigFileData
	}
	return nil
}

type AddTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddTunnelResponse) Reset() {
	*x = AddTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddTunnelResponse) ProtoMessage() {}

func (x *AddTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddTunnelResponse.ProtoReflect.Descriptor instead.
func (*AddTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{21}
}

func (x *AddTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AddTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RemoveTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveTunnelRequest) Reset() {
	*x = RemoveTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveTunnelRequest) ProtoMessage() {}

func (x *RemoveTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveTunnelRequest.ProtoReflect.Descriptor instead.
func (*RemoveTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{22}
}

func (x *RemoveTunnelRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type RemoveTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveTunnelResponse) Reset() {
	*x = RemoveTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveTunnelResponse) ProtoMessage() {}

func (x *RemoveTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveTunnelResponse.ProtoReflect.Descriptor instead.
func (*RemoveTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{23}
}

func (x *RemoveTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RemoveTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type UpdateTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *TunnelConfig          `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTunnelRequest) Reset() {
	*x = UpdateTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTunnelRequest) ProtoMessage() {}

func (x *UpdateTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTunnelRequest.ProtoReflect.Descriptor instead.
func (*UpdateTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{24}
}

func (x *UpdateTunnelRequest) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type UpdateTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTunnelResponse) Reset() {
	*x = UpdateTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTunnelResponse) ProtoMessage() {}

func (x *UpdateTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTunnelResponse.ProtoReflect.Descriptor instead.
func (*UpdateTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{25}
}

func (x *UpdateTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type GetTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTunnelRequest) Reset() {
	*x = GetTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTunnelRequest) ProtoMessage() {}

func (x *GetTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTunnelRequest.ProtoReflect.Descriptor instead.
func (*GetTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{26}
}

func (x *GetTunnelRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type TunnelListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tunnels       []*TunnelStatus        `protobuf:"bytes,1,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelListResponse) Reset() {
	*x = TunnelListResponse{}
	mi := &file_vpn_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelListResponse) ProtoMessage() {}

func (x *TunnelListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelListResponse.ProtoReflect.Descriptor instead.
func (*TunnelListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{27}
}

func (x *TunnelListResponse) GetTunnels() []*TunnelStatus {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

type SaveTunnelOrderRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelIds     []string               `protobuf:"bytes,1,rep,name=tunnel_ids,json=tunnelIds,proto3" json:"tunnel_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveTunnelOrderRequest) Reset() {
	*x = SaveTunnelOrderRequest{}
	mi := &file_vpn_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveTunnelOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveTunnelOrderRequest) ProtoMessage() {}

func (x *SaveTunnelOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveTunnelOrderRequest.ProtoReflect.Descriptor instead.
func (*SaveTunnelOrderRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{28}
}

func (x *SaveTunnelOrderRequest) GetTunnelIds() []string {
	if x != nil {
		return x.TunnelIds
	}
	return nil
}

type SaveTunnelOrderResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveTunnelOrderResponse) Reset() {
	*x = SaveTunnelOrderResponse{}
	mi := &file_vpn_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveTunnelOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveTunnelOrderResponse) ProtoMessage() {}

func (x *SaveTunnelOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveTunnelOrderResponse.ProtoReflect.Descriptor instead.
func (*SaveTunnelOrderResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{29}
}

func (x *SaveTunnelOrderResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveTunnelOrderResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RuleListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*Rule                `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RuleListResponse) Reset() {
	*x = RuleListResponse{}
	mi := &file_vpn_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RuleListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuleListResponse) ProtoMessage() {}

func (x *RuleListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuleListResponse.ProtoReflect.Descriptor instead.
func (*RuleListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{30}
}

func (x *RuleListResponse) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveRulesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*Rule                `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveRulesRequest) Reset() {
	*x = SaveRulesRequest{}
	mi := &file_vpn_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveRulesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveRulesRequest) ProtoMessage() {}

func (x *SaveRulesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveRulesRequest.ProtoReflect.Descriptor instead.
func (*SaveRulesRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{31}
}

func (x *SaveRulesRequest) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveRulesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveRulesResponse) Reset() {
	*x = SaveRulesResponse{}
	mi := &file_vpn_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveRulesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveRulesResponse) ProtoMessage() {}

func (x *SaveRulesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveRulesResponse.ProtoReflect.Descriptor instead.
func (*SaveRulesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{32}
}

func (x *SaveRulesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveRulesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type DomainRuleListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*DomainRule          `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DomainRuleListResponse) Reset() {
	*x = DomainRuleListResponse{}
	mi := &file_vpn_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DomainRuleListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DomainRuleListResponse) ProtoMessage() {}

func (x *DomainRuleListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DomainRuleListResponse.ProtoReflect.Descriptor instead.
func (*DomainRuleListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{33}
}

func (x *DomainRuleListResponse) GetRules() []*DomainRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveDomainRulesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*DomainRule          `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveDomainRulesRequest) Reset() {
	*x = SaveDomainRulesRequest{}
	mi := &file_vpn_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveDomainRulesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveDomainRulesRequest) ProtoMessage() {}

func (x *SaveDomainRulesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveDomainRulesRequest.ProtoReflect.Descriptor instead.
func (*SaveDomainRulesRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{34}
}

func (x *SaveDomainRulesRequest) GetRules() []*DomainRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveDomainRulesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveDomainRulesResponse) Reset() {
	*x = SaveDomainRulesResponse{}
	mi := &file_vpn_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveDomainRulesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveDomainRulesResponse) ProtoMessage() {}

func (x *SaveDomainRulesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveDomainRulesResponse.ProtoReflect.Descriptor instead.
func (*SaveDomainRulesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{35}
}

func (x *SaveDomainRulesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveDomainRulesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type GeositeCategoriesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Categories    []string               `protobuf:"bytes,1,rep,name=categories,proto3" json:"categories,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeositeCategoriesResponse) Reset() {
	*x = GeositeCategoriesResponse{}
	mi := &file_vpn_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeositeCategoriesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeositeCategoriesResponse) ProtoMessage() {}

func (x *GeositeCategoriesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeositeCategoriesResponse.ProtoReflect.Descriptor instead.
func (*GeositeCategoriesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{36}
}

func (x *GeositeCategoriesResponse) GetCategories() []string {
	if x != nil {
		return x.Categories
	}
	return nil
}

type UpdateGeositeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateGeositeResponse) Reset() {
	*x = UpdateGeositeResponse{}
	mi := &file_vpn_service_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateGeositeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateGeositeResponse) ProtoMessage() {}

func (x *UpdateGeositeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateGeositeResponse.ProtoReflect.Descriptor instead.
func (*UpdateGeositeResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{37}
}

func (x *UpdateGeositeResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateGeositeResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type SaveConfigRequest struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Config             *AppConfig             `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	RestartIfConnected bool                   `protobuf:"varint,2,opt,name=restart_if_connected,json=restartIfConnected,proto3" json:"restart_if_connected,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SaveConfigRequest) Reset() {
	*x = SaveConfigRequest{}
	mi := &file_vpn_service_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveConfigRequest) ProtoMessage() {}

func (x *SaveConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveConfigRequest.ProtoReflect.Descriptor instead.
func (*SaveConfigRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{38}
}

func (x *SaveConfigRequest) GetConfig() *AppConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *SaveConfigRequest) GetRestartIfConnected() bool {
	if x != nil {
		return x.RestartIfConnected
	}
	return false
}

type SaveConfigResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Restarted     bool                   `protobuf:"varint,3,opt,name=restarted,proto3" json:"restarted,omitempty"` // true if VPN was restarted
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveConfigResponse) Reset() {
	*x = SaveConfigResponse{}
	mi := &file_vpn_service_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveConfigResponse) ProtoMessage() {}

func (x *SaveConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveConfigResponse.ProtoReflect.Descriptor instead.
func (*SaveConfigResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{39}
}

func (x *SaveConfigResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveConfigResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *SaveConfigResponse) GetRestarted() bool {
	if x != nil {
		return x.Restarted
	}
	return false
}

type LogStreamRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinLevel      LogLevel               `protobuf:"varint,1,opt,name=min_level,json=minLevel,proto3,enum=awg.vpn.v1.LogLevel" json:"min_level,omitempty"` // minimum level to stream
	TagFilter     string                 `protobuf:"bytes,2,opt,name=tag_filter,json=tagFilter,proto3" json:"tag_filter,omitempty"`                        // optional: filter by tag
	TailLines     int32                  `protobuf:"varint,3,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`                       // send last N lines first (0 = no history)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogStreamRequest) Reset() {
	*x = LogStreamRequest{}
	mi := &file_vpn_service_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogStreamRequest) ProtoMessage() {}

func (x *LogStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogStreamRequest.ProtoReflect.Descriptor instead.
func (*LogStreamRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{40}
}

func (x *LogStreamRequest) GetMinLevel() LogLevel {
	if x != nil {
		return x.MinLevel
	}
	return LogLevel_LOG_LEVEL_DEBUG
}

func (x *LogStreamRequest) GetTagFilter() string {
	if x != nil {
		return x.TagFilter
	}
	return ""
}

func (x *LogStreamRequest) GetTailLines() int32 {
	if x != nil {
		return x.TailLines
	}
	return 0
}

type StatsStreamRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IntervalMs    int32                  `protobuf:"varint,1,opt,name=interval_ms,json=intervalMs,proto3" json:"interval_ms,omitempty"` // update interval (default: 1000)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsStreamRequest) Reset() {
	*x = StatsStreamRequest{}
	mi := &file_vpn_service_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsStreamRequest) ProtoMessage() {}

func (x *StatsStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsStreamRequest.ProtoReflect.Descriptor instead.
func (*StatsStreamRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{41}
}

func (x *StatsStreamRequest) GetIntervalMs() int32 {
	if x != nil {
		return x.IntervalMs
	}
	return 0
}

type ProcessListRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NameFilter    string                 `protobuf:"bytes,1,opt,name=name_filter,json=nameFilter,proto3" json:"name_filter,omitempty"` // optional: filter by name substring
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessListRequest) Reset() {
	*x = ProcessListRequest{}
	mi := &file_vpn_service_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessListRequest) ProtoMessage() {}

func (x *ProcessListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessListRequest.ProtoReflect.Descriptor instead.
func (*ProcessListRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{42}
}

func (x *ProcessListRequest) GetNameFilter() string {
	if x != nil {
		return x.NameFilter
	}
	return ""
}

type ProcessListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Processes     []*ProcessInfo         `protobuf:"bytes,1,rep,name=processes,proto3" json:"processes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessListResponse) Reset() {
	*x = ProcessListResponse{}
	mi := &file_vpn_service_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessListResponse) ProtoMessage() {}

func (x *ProcessListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessListResponse.ProtoReflect.Descriptor instead.
func (*ProcessListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{43}
}

func (x *ProcessListResponse) GetProcesses() []*ProcessInfo {
	if x != nil {
		return x.Processes
	}
	return nil
}

type SubscriptionListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Subscriptions []*SubscriptionStatus  `protobuf:"bytes,1,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscriptionListResponse) Reset() {
	*x = SubscriptionListResponse{}
	mi := &file_vpn_service_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriptionListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriptionListResponse) ProtoMessage() {}

func (x *SubscriptionListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriptionListResponse.ProtoReflect.Descriptor instead.
func (*SubscriptionListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{44}
}

func (x *SubscriptionListResponse) GetSubscriptions() []*SubscriptionStatus {
	if x != nil {
		return x.Subscriptions
	}
	return nil
}

type AddSubscriptionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *SubscriptionConfig    `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddSubscriptionRequest) Reset() {
	*x = AddSubscriptionRequest{}
	mi := &file_vpn_service_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddSubscriptionRequest) ProtoMessage() {}

func (x *AddSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*AddSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{45}
}

func (x *AddSubscriptionRequest) GetConfig() *SubscriptionConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type AddSubscriptionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	TunnelCount   int32                  `protobuf:"varint,3,opt,name=tunnel_count,json=tunnelCount,proto3" json:"tunnel_count,omitempty"` // number of tunnels fetched on initial refresh
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddSubscriptionResponse) Reset() {
	*x = AddSubscriptionResponse{}
	mi := &file_vpn_service_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddSubscriptionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddSubscriptionResponse) ProtoMessage() {}

func (x *AddSubscriptionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddSubscriptionResponse.ProtoReflect.Descriptor instead.
func (*AddSubscriptionResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{46}
}

func (x *AddSubscriptionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AddSubscriptionResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AddSubscriptionResponse) GetTunnelCount() int32 {
	if x != nil {
		return x.TunnelCount
	}
	return 0
}

type RemoveSubscriptionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveSubscriptionRequest) Reset() {
	*x = RemoveSubscriptionRequest{}
	mi := &file_vpn_service_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveSubscriptionRequest) ProtoMessage() {}

func (x *RemoveSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*RemoveSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{47}
}

func (x *RemoveSubscriptionRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type RemoveSubscriptionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveSubscriptionResponse) Reset() {
	*x = RemoveSubscriptionResponse{}
	mi := &file_vpn_service_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveSubscriptionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveSubscriptionResponse) ProtoMessage() {}

func (x *RemoveSubscriptionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveSubscriptionResponse.ProtoReflect.Descriptor instead.
func (*RemoveSubscriptionResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{48}
}

func (x *RemoveSubscriptionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RemoveSubscriptionResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RefreshSubscriptionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // specific subscription, or empty for all
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshSubscriptionRequest) Reset() {
	*x = RefreshSubscriptionRequest{}
	mi := &file_vpn_service_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshSubscriptionRequest) ProtoMessage() {}

func (x *RefreshSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*RefreshSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{49}
}

func (x *RefreshSubscriptionRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type RefreshSubscriptionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	TunnelCount   int32                  `protobuf:"varint,3,opt,name=tunnel_count,json=tunnelCount,proto3" json:"tunnel_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshSubscriptionResponse) Reset() {
	*x = RefreshSubscriptionResponse{}
	mi := &file_vpn_service_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshSubscriptionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshSubscriptionResponse) ProtoMessage() {}

func (x *RefreshSubscriptionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshSubscriptionResponse.ProtoReflect.Descriptor instead.
func (*RefreshSubscriptionResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{50}
}

func (x *RefreshSubscriptionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RefreshSubscriptionResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RefreshSubscriptionResponse) GetTunnelCount() int32 {
	if x != nil {
		return x.TunnelCount
	}
	return 0
}

type ServiceStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Running       bool                   `protobuf:"varint,1,opt,name=running,proto3" json:"running,omitempty"`
	ActiveTunnels int32                  `protobuf:"varint,2,opt,name=active_tunnels,json=activeTunnels,proto3" json:"active_tunnels,omitempty"`
	TotalTunnels  int32                  `protobuf:"varint,3,opt,name=total_tunnels,json=totalTunnels,proto3" json:"total_tunnels,omitempty"`
	Version       string                 `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	UptimeSeconds int64                  `protobuf:"varint,5,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceStatus) Reset() {
	*x = ServiceStatus{}
	mi := &file_vpn_service_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceStatus) ProtoMessage() {}

func (x *ServiceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceStatus.ProtoReflect.Descriptor instead.
func (*ServiceStatus) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{51}
}

func (x *ServiceStatus) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *ServiceStatus) GetActiveTunnels() int32 {
	if x != nil {
		return x.ActiveTunnels
	}
	return 0
}

func (x *ServiceStatus) GetTotalTunnels() int32 {
	if x != nil {
		return x.TotalTunnels
	}
	return 0
}

func (x *ServiceStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ServiceStatus) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

type UpdateInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`                               // new version string (e.g. "1.2.0")
	ReleaseNotes  string                 `protobuf:"bytes,2,opt,name=release_notes,json=releaseNotes,proto3" json:"release_notes,omitempty"` // markdown release notes
	AssetUrl      string                 `protobuf:"bytes,3,opt,name=asset_url,json=assetUrl,proto3" json:"asset_url,omitempty"`             // download URL
	AssetSize     int64                  `protobuf:"varint,4,opt,name=asset_size,json=assetSize,proto3" json:"asset_size,omitempty"`         // asset size in bytes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateInfo) Reset() {
	*x = UpdateInfo{}
	mi := &file_vpn_service_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateInfo) ProtoMessage() {}

func (x *UpdateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateInfo.ProtoReflect.Descriptor instead.
func (*UpdateInfo) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{52}
}

func (x *UpdateInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *UpdateInfo) GetReleaseNotes() string {
	if x != nil {
		return x.ReleaseNotes
	}
	return ""
}

func (x *UpdateInfo) GetAssetUrl() string {
	if x != nil {
		return x.AssetUrl
	}
	return ""
}

func (x *UpdateInfo) GetAssetSize() int64 {
	if x != nil {
		return x.AssetSize
	}
	return 0
}

type CheckUpdateResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     bool                   `protobuf:"varint,1,opt,name=available,proto3" json:"available,omitempty"`
	Info          *UpdateInfo            `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckUpdateResponse) Reset() {
	*x = CheckUpdateResponse{}
	mi := &file_vpn_service_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckUpdateResponse) ProtoMessage() {}

func (x *CheckUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckUpdateResponse.ProtoReflect.Descriptor instead.
func (*CheckUpdateResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{53}
}

func (x *CheckUpdateResponse) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

func (x *CheckUpdateResponse) GetInfo() *UpdateInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

type ApplyUpdateResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyUpdateResponse) Reset() {
	*x = ApplyUpdateResponse{}
	mi := &file_vpn_service_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyUpdateResponse) ProtoMessage() {}

func (x *ApplyUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyUpdateResponse.ProtoReflect.Descriptor instead.
func (*ApplyUpdateResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{54}
}

func (x *ApplyUpdateResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ApplyUpdateResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type AutostartConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Enabled            bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	RestoreConnections bool                   `protobuf:"varint,2,opt,name=restore_connections,json=restoreConnections,proto3" json:"restore_connections,omitempty"` // auto-connect on startup
	GuiExePath         string                 `protobuf:"bytes,3,opt,name=gui_exe_path,json=guiExePath,proto3" json:"gui_exe_path,omitempty"`                        // path to GUI executable (for scheduled task creation)
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *AutostartConfig) Reset() {
	*x = AutostartConfig{}
	mi := &file_vpn_service_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutostartConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutostartConfig) ProtoMessage() {}

func (x *AutostartConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutostartConfig.ProtoReflect.Descriptor instead.
func (*AutostartConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{55}
}

func (x *AutostartConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *AutostartConfig) GetRestoreConnections() bool {
	if x != nil {
		return x.RestoreConnections
	}
	return false
}

func (x *AutostartConfig) GetGuiExePath() string {
	if x != nil {
		return x.GuiExePath
	}
	return ""
}

type SetAutostartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *AutostartConfig       `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAutostartRequest) Reset() {
	*x = SetAutostartRequest{}
	mi := &file_vpn_service_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAutostartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAutostartRequest) ProtoMessage() {}

func (x *SetAutostartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAutostartRequest.ProtoReflect.Descriptor instead.
func (*SetAutostartRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{56}
}

func (x *SetAutostartRequest) GetConfig() *AutostartConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetAutostartResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAutostartResponse) Reset() {
	*x = SetAutostartResponse{}
	mi := &file_vpn_service_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAutostartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAutostartResponse) ProtoMessage() {}

func (x *SetAutostartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAutostartResponse.ProtoReflect.Descriptor instead.
func (*SetAutostartResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{57}
}

func (x *SetAutostartResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SetAutostartResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ConflictingService struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                  // service or process name
	DisplayName   string                 `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"` // human-readable name
	Type          string                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`                                  // "service" or "process"
	Running       bool                   `protobuf:"varint,4,opt,name=running,proto3" json:"running,omitempty"`                           // true if currently active
	Description   string                 `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`                    // why it conflicts
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConflictingService) Reset() {
	*x = ConflictingService{}
	mi := &file_vpn_service_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictingService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictingService) ProtoMessage() {}

func (x *ConflictingService) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConflictingService.ProtoReflect.Descriptor instead.
func (*ConflictingService) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{58}
}

func (x *ConflictingService) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ConflictingService) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *ConflictingService) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ConflictingService) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *ConflictingService) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type ConflictingServicesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Services      []*ConflictingService  `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConflictingServicesResponse) Reset() {
	*x = ConflictingServicesResponse{}
	mi := &file_vpn_service_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictingServicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictingServicesResponse) ProtoMessage() {}

func (x *ConflictingServicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConflictingServicesResponse.ProtoReflect.Descriptor instead.
func (*ConflictingServicesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{59}
}

func (x *ConflictingServicesResponse) GetServices() []*ConflictingService {
	if x != nil {
		return x.Services
	}
	return nil
}

type StopConflictingServicesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Names         []string               `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"` // service/process names to stop
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopConflictingServicesRequest) Reset() {
	*x = StopConflictingServicesRequest{}
	mi := &file_vpn_service_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopConflictingServicesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopConflictingServicesRequest) ProtoMessage() {}

func (x *StopConflictingServicesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopConflictingServicesRequest.ProtoReflect.Descriptor instead.
func (*StopConflictingServicesRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{60}
}

func (x *StopConflictingServicesRequest) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

type StopConflictingServicesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Stopped       []string               `protobuf:"bytes,3,rep,name=stopped,proto3" json:"stopped,omitempty"` // successfully stopped
	Failed        []string               `protobuf:"bytes,4,rep,name=failed,proto3" json:"failed,omitempty"`   // failed to stop
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopConflictingServicesResponse) Reset() {
	*x = StopConflictingServicesResponse{}
	mi := &file_vpn_service_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopConflictingServicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopConflictingServicesResponse) ProtoMessage() {}

func (x *StopConflictingServicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopConflictingServicesResponse.ProtoReflect.Descriptor instead.
func (*StopConflictingServicesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{61}
}

func (x *StopConflictingServicesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopConflictingServicesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *StopConflictingServicesResponse) GetStopped() []string {
	if x != nil {
		return x.Stopped
	}
	return nil
}

func (x *StopConflictingServicesResponse) GetFailed() []string {
	if x != nil {
		return x.Failed
	}
	return nil
}

var File_vpn_service_proto protoreflect.FileDescriptor

const file_vpn_service_proto_rawDesc = "" +
	"\n" +
	"\x11vpn_service.proto\x12\n" +
	"awg.vpn.v1\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xdf\x02\n" +
	"\fTunnelConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12B\n" +
	"\bsettings\x18\x04 \x03(\v2&.awg.vpn.v1.TunnelConfig.SettingsEntryR\bsettings\x12\x1f\n" +
	"\vallowed_ips\x18\x05 \x03(\tR\n" +
	"allowedIps\x12%\n" +
	"\x0edisallowed_ips\x18\x06 \x03(\tR\rdisallowedIps\x12'\n" +
	"\x0fdisallowed_apps\x18\a \x03(\tR\x0edisallowedApps\x12\x1d\n" +
	"\n" +
	"sort_index\x18\b \x01(\x05R\tsortIndex\x1a;\n" +
	"\rSettingsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x97\x02\n" +
	"\fTunnelStatus\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x120\n" +
	"\x06config\x18\x02 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\x12-\n" +
	"\x05state\x18\x03 \x01(\x0e2\x17.awg.vpn.v1.TunnelStateR\x05state\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"adapter_ip\x18\x05 \x01(\tR\tadapterIp\x12\x1f\n" +
	"\vexternal_ip\x18\x06 \x01(\tR\n" +
	"externalIp\x12!\n" +
	"\fcountry_code\x18\a \x01(\tR\vcountryCode\x12\x1d\n" +
	"\n" +
	"sort_index\x18\b \x01(\x05R\tsortIndex\"\x8d\x01\n" +
	"\n" +
	"DomainRule\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x1b\n" +
	"\ttunnel_id\x18\x02 \x01(\tR\btunnelId\x120\n" +
	"\x06action\x18\x03 \x01(\x0e2\x18.awg.vpn.v1.DomainActionR\x06action\x12\x16\n" +
	"\x06active\x18\x04 \x01(\bR\x06active\"\xa9\x01\n" +
	"\x04Rule\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x1b\n" +
	"\ttunnel_id\x18\x02 \x01(\tR\btunnelId\x126\n" +
	"\bfallback\x18\x03 \x01(\x0e2\x1a.awg.vpn.v1.FallbackPolicyR\bfallback\x12\x1a\n" +
	"\bpriority\x18\x04 \x01(\tR\bpriority\x12\x16\n" +
	"\x06active\x18\x05 \x01(\bR\x06active\"\x90\x01\n" +
	"\x0eDNSCacheConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x19\n" +
	"\bmax_size\x18\x02 \x01(\x05R\amaxSize\x12\x17\n" +
	"\amin_ttl\x18\x03 \x01(\tR\x06minTtl\x12\x17\n" +
	"\amax_ttl\x18\x04 \x01(\tR\x06maxTtl\x12\x17\n" +
	"\aneg_ttl\x18\x05 \x01(\tR\x06negTtl\"\x93\x01\n" +
	"\tDNSConfig\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\x12\x18\n" +
	"\aservers\x18\x02 \x03(\tR\aservers\x120\n" +
	"\x05cache\x18\x03 \x01(\v2\x1a.awg.vpn.v1.DNSCacheConfigR\x05cache\x12\x1d\n" +
	"\n" +
	"tunnel_ids\x18\x04 \x03(\tR\ttunnelIds\"\xaa\x01\n" +
	"\x12GlobalFilterConfig\x12\x1f\n" +
	"\vallowed_ips\x18\x01 \x03(\tR\n" +
	"allowedIps\x12%\n" +
	"\x0edisallowed_ips\x18\x02 \x03(\tR\rdisallowedIps\x12'\n" +
	"\x0fdisallowed_apps\x18\x03 \x03(\tR\x0edisallowedApps\x12#\n" +
	"\rdisable_local\x18\x04 \x01(\bR\fdisableLocal\"\xd9\x01\n" +
	"\tLogConfig\x12\x14\n" +
	"\x05level\x18\x01 \x01(\tR\x05level\x12E\n" +
	"\n" +
	"components\x18\x02 \x03(\v2%.awg.vpn.v1.LogConfig.ComponentsEntryR\n" +
	"components\x120\n" +
	"\x14file_logging_enabled\x18\x03 \x01(\bR\x12fileLoggingEnabled\x1a=\n" +
	"\x0fComponentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9c\x01\n" +
	"\x12SubscriptionConfig\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x12)\n" +
	"\x10refresh_interval\x18\x03 \x01(\tR\x0frefreshInterval\x12\x1d\n" +
	"\n" +
	"user_agent\x18\x04 \x01(\tR\tuserAgent\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\"\x8e\x01\n" +
	"\x12SubscriptionStatus\x126\n" +
	"\x06config\x18\x01 \x01(\v2\x1e.awg.vpn.v1.SubscriptionConfigR\x06config\x12!\n" +
	"\ftunnel_count\x18\x02 \x01(\x05R\vtunnelCount\x12\x1d\n" +
	"\n" +
	"last_error\x18\x03 \x01(\tR\tlastError\"h\n" +
	"\x0fReconnectConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
	"\binterval\x18\x02 \x01(\tR\binterval\x12\x1f\n" +
	"\vmax_retries\x18\x03 \x01(\x05R\n" +
	"maxRetries\"\xb5\x03\n" +
	"\tAppConfig\x126\n" +
	"\x06global\x18\x01 \x01(\v2\x1e.awg.vpn.v1.GlobalFilterConfigR\x06global\x122\n" +
	"\atunnels\x18\x02 \x03(\v2\x18.awg.vpn.v1.TunnelConfigR\atunnels\x12&\n" +
	"\x05rules\x18\x03 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\x12'\n" +
	"\x03dns\x18\x04 \x01(\v2\x15.awg.vpn.v1.DNSConfigR\x03dns\x12/\n" +
	"\alogging\x18\x05 \x01(\v2\x15.awg.vpn.v1.LogConfigR\alogging\x129\n" +
	"\fdomain_rules\x18\x06 \x03(\v2\x16.awg.vpn.v1.DomainRuleR\vdomainRules\x12D\n" +
	"\rsubscriptions\x18\a \x03(\v2\x1e.awg.vpn.v1.SubscriptionConfigR\rsubscriptions\x129\n" +
	"\treconnect\x18\b \x01(\v2\x1b.awg.vpn.v1.ReconnectConfigR\treconnect\"\xe5\x02\n" +
	"\vTunnelStats\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\x12-\n" +
	"\x05state\x18\x02 \x01(\x0e2\x17.awg.vpn.v1.TunnelStateR\x05state\x12\x19\n" +
	"\bbytes_tx\x18\x03 \x01(\x03R\abytesTx\x12\x19\n" +
	"\bbytes_rx\x18\x04 \x01(\x03R\abytesRx\x12\x19\n" +
	"\bspeed_tx\x18\x05 \x01(\x03R\aspeedTx\x12\x19\n" +
	"\bspeed_rx\x18\x06 \x01(\x03R\aspeedRx\x12\x1f\n" +
	"\vpacket_loss\x18\a \x01(\x01R\n" +
	"packetLoss\x12\x1d\n" +
	"\n" +
	"latency_ms\x18\b \x01(\x03R\tlatencyMs\x12A\n" +
	"\x0elast_handshake\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\rlastHandshake\x12\x1b\n" +
	"\tjitter_ms\x18\n" +
	" \x01(\x03R\bjitterMs\"|\n" +
	"\rStatsSnapshot\x121\n" +
	"\atunnels\x18\x01 \x03(\v2\x17.awg.vpn.v1.TunnelStatsR\atunnels\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"\x9c\x01\n" +
	"\bLogEntry\x128\n" +
	"\ttimestamp\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12*\n" +
	"\x05level\x18\x02 \x01(\x0e2\x14.awg.vpn.v1.LogLevelR\x05level\x12\x10\n" +
	"\x03tag\x18\x03 \x01(\tR\x03tag\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"G\n" +
	"\vProcessInfo\x12\x10\n" +
	"\x03pid\x18\x01 \x01(\rR\x03pid\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\"-\n" +
	"\x0eConnectRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"A\n" +
	"\x0fConnectResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"0\n" +
	"\x11DisconnectRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"D\n" +
	"\x12DisconnectResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"n\n" +
	"\x10AddTunnelRequest\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\x12(\n" +
	"\x10config_file_data\x18\x02 \x01(\fR\x0econfigFileData\"C\n" +
	"\x11AddTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"2\n" +
	"\x13RemoveTunnelRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"F\n" +
	"\x14RemoveTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"G\n" +
	"\x13UpdateTunnelRequest\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\"F\n" +
	"\x14UpdateTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"/\n" +
	"\x10GetTunnelRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"H\n" +
	"\x12TunnelListResponse\x122\n" +
	"\atunnels\x18\x01 \x03(\v2\x18.awg.vpn.v1.TunnelStatusR\atunnels\"7\n" +
	"\x16SaveTunnelOrderRequest\x12\x1d\n" +
	"\n" +
	"tunnel_ids\x18\x01 \x03(\tR\ttunnelIds\"I\n" +
	"\x17SaveTunnelOrderResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\":\n" +
	"\x10RuleListResponse\x12&\n" +
	"\x05rules\x18\x01 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\":\n" +
	"\x10SaveRulesRequest\x12&\n" +
	"\x05rules\x18\x01 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\"C\n" +
	"\x11SaveRulesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"F\n" +
	"\x16DomainRuleListResponse\x12,\n" +
	"\x05rules\x18\x01 \x03(\v2\x16.awg.vpn.v1.DomainRuleR\x05rules\"F\n" +
	"\x16SaveDomainRulesRequest\x12,\n" +
	"\x05rules\x18\x01 \x03(\v2\x16.awg.vpn.v1.DomainRuleR\x05rules\"I\n" +
	"\x17SaveDomainRulesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\";\n" +
	"\x19GeositeCategoriesResponse\x12\x1e\n" +
	"\n" +
	"categories\x18\x01 \x03(\tR\n" +
	"categories\"G\n" +
	"\x15UpdateGeositeResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"t\n" +
	"\x11SaveConfigRequest\x12-\n" +
	"\x06config\x18\x01 \x01(\v2\x15.awg.vpn.v1.AppConfigR\x06config\x120\n" +
	"\x14restart_if_connected\x18\x02 \x01(\bR\x12restartIfConnected\"b\n" +
	"\x12SaveConfigResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1c\n" +
	"\trestarted\x18\x03 \x01(\bR\trestarted\"\x83\x01\n" +
	"\x10LogStreamRequest\x121\n" +
	"\tmin_level\x18\x01 \x01(\x0e2\x14.awg.vpn.v1.LogLevelR\bminLevel\x12\x1d\n" +
	"\n" +
	"tag_filter\x18\x02 \x01(\tR\ttagFilter\x12\x1d\n" +
	"\n" +
	"tail_lines\x18\x03 \x01(\x05R\ttailLines\"5\n" +
	"\x12StatsStreamRequest\x12\x1f\n" +
	"\vinterval_ms\x18\x01 \x01(\x05R\n" +
	"intervalMs\"5\n" +
	"\x12ProcessListRequest\x12\x1f\n" +
	"\vname_filter\x18\x01 \x01(\tR\n" +
	"nameFilter\"L\n" +
	"\x13ProcessListResponse\x125\n" +
	"\tprocesses\x18\x01 \x03(\v2\x17.awg.vpn.v1.ProcessInfoR\tprocesses\"`\n" +
	"\x18SubscriptionListResponse\x12D\n" +
	"\rsubscriptions\x18\x01 \x03(\v2\x1e.awg.vpn.v1.SubscriptionStatusR\rsubscriptions\"P\n" +
	"\x16AddSubscriptionRequest\x126\n" +
	"\x06config\x18\x01 \x01(\v2\x1e.awg.vpn.v1.SubscriptionConfigR\x06config\"l\n" +
	"\x17AddSubscriptionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12!\n" +
	"\ftunnel_count\x18\x03 \x01(\x05R\vtunnelCount\"/\n" +
	"\x19RemoveSubscriptionRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"L\n" +
	"\x1aRemoveSubscriptionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"0\n" +
	"\x1aRefreshSubscriptionRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"p\n" +
	"\x1bRefreshSubscriptionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12!\n" +
	"\ftunnel_count\x18\x03 \x01(\x05R\vtunnelCount\"\xb6\x01\n" +
	"\rServiceStatus\x12\x18\n" +
	"\arunning\x18\x01 \x01(\bR\arunning\x12%\n" +
	"\x0eactive_tunnels\x18\x02 \x01(\x05R\ractiveTunnels\x12#\n" +
	"\rtotal_tunnels\x18\x03 \x01(\x05R\ftotalTunnels\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12%\n" +
	"\x0euptime_seconds\x18\x05 \x01(\x03R\ruptimeSeconds\"\x87\x01\n" +
	"\n" +
	"UpdateInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12#\n" +
	"\rrelease_notes\x18\x02 \x01(\tR\freleaseNotes\x12\x1b\n" +
	"\tasset_url\x18\x03 \x01(\tR\bassetUrl\x12\x1d\n" +
	"\n" +
	"asset_size\x18\x04 \x01(\x03R\tassetSize\"_\n" +
	"\x13CheckUpdateResponse\x12\x1c\n" +
	"\tavailable\x18\x01 \x01(\bR\tavailable\x12*\n" +
	"\x04info\x18\x02 \x01(\v2\x16.awg.vpn.v1.UpdateInfoR\x04info\"E\n" +
	"\x13ApplyUpdateResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"~\n" +
	"\x0fAutostartConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12/\n" +
	"\x13restore_connections\x18\x02 \x01(\bR\x12restoreConnections\x12 \n" +
	"\fgui_exe_path\x18\x03 \x01(\tR\n" +
	"guiExePath\"J\n" +
	"\x13SetAutostartRequest\x123\n" +
	"\x06config\x18\x01 \x01(\v2\x1b.awg.vpn.v1.AutostartConfigR\x06config\"F\n" +
	"\x14SetAutostartResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x9b\x01\n" +
	"\x12ConflictingService\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x02 \x01(\tR\vdisplayName\x12\x12\n" +
	"\x04type\x18\x03 \x01(\tR\x04type\x12\x18\n" +
	"\arunning\x18\x04 \x01(\bR\arunning\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\"Y\n" +
	"\x1bConflictingServicesResponse\x12:\n" +
	"\bservices\x18\x01 \x03(\v2\x1e.awg.vpn.v1.ConflictingServiceR\bservices\"6\n" +
	"\x1eStopConflictingServicesRequest\x12\x14\n" +
	"\x05names\x18\x01 \x03(\tR\x05names\"\x83\x01\n" +
	"\x1fStopConflictingServicesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x18\n" +
	"\astopped\x18\x03 \x03(\tR\astopped\x12\x16\n" +
	"\x06failed\x18\x04 \x03(\tR\x06failed*n\n" +
	"\vTunnelState\x12\x15\n" +
	"\x11TUNNEL_STATE_DOWN\x10\x00\x12\x1b\n" +
	"\x17TUNNEL_STATE_CONNECTING\x10\x01\x12\x13\n" +
	"\x0fTUNNEL_STATE_UP\x10\x02\x12\x16\n" +
	"\x12TUNNEL_STATE_ERROR\x10\x03*i\n" +
	"\x0eFallbackPolicy\x12\x19\n" +
	"\x15FALLBACK_ALLOW_DIRECT\x10\x00\x12\x12\n" +
	"\x0eFALLBACK_BLOCK\x10\x01\x12\x11\n" +
	"\rFALLBACK_DROP\x10\x02\x12\x15\n" +
	"\x11FALLBACK_FAILOVER\x10\x03*o\n" +
	"\bLogLevel\x12\x13\n" +
	"\x0fLOG_LEVEL_DEBUG\x10\x00\x12\x12\n" +
	"\x0eLOG_LEVEL_INFO\x10\x01\x12\x12\n" +
	"\x0eLOG_LEVEL_WARN\x10\x02\x12\x13\n" +
	"\x0fLOG_LEVEL_ERROR\x10\x03\x12\x11\n" +
	"\rLOG_LEVEL_OFF\x10\x04*Z\n" +
	"\fDomainAction\x12\x17\n" +
	"\x13DOMAIN_ACTION_ROUTE\x10\x00\x12\x18\n" +
	"\x14DOMAIN_ACTION_DIRECT\x10\x01\x12\x17\n" +
	"\x13DOMAIN_ACTION_BLOCK\x10\x022\xd9\x15\n" +
	"\n" +
	"VPNService\x12>\n" +
	"\tGetStatus\x12\x16.google.protobuf.Empty\x1a\x19.awg.vpn.v1.ServiceStatus\x12:\n" +
	"\bShutdown\x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.Empty\x12E\n" +
	"\vListTunnels\x12\x16.google.protobuf.Empty\x1a\x1e.awg.vpn.v1.TunnelListResponse\x12C\n" +
	"\tGetTunnel\x12\x1c.awg.vpn.v1.GetTunnelRequest\x1a\x18.awg.vpn.v1.TunnelStatus\x12H\n" +
	"\tAddTunnel\x12\x1c.awg.vpn.v1.AddTunnelRequest\x1a\x1d.awg.vpn.v1.AddTunnelResponse\x12Q\n" +
	"\fRemoveTunnel\x12\x1f.awg.vpn.v1.RemoveTunnelRequest\x1a .awg.vpn.v1.RemoveTunnelResponse\x12Q\n" +
	"\fUpdateTunnel\x12\x1f.awg.vpn.v1.UpdateTunnelRequest\x1a .awg.vpn.v1.UpdateTunnelResponse\x12B\n" +
	"\aConnect\x12\x1a.awg.vpn.v1.ConnectRequest\x1a\x1b.awg.vpn.v1.ConnectResponse\x12K\n" +
	"\n" +
	"Disconnect\x12\x1d.awg.vpn.v1.DisconnectRequest\x1a\x1e.awg.vpn.v1.DisconnectResponse\x12H\n" +
	"\rRestartTunnel\x12\x1a.awg.vpn.v1.ConnectRequest\x1a\x1b.awg.vpn.v1.ConnectResponse\x12Z\n" +
	"\x0fSaveTunnelOrder\x12\".awg.vpn.v1.SaveTunnelOrderRequest\x1a#.awg.vpn.v1.SaveTunnelOrderResponse\x12A\n" +
	"\tListRules\x12\x16.google.protobuf.Empty\x1a\x1c.awg.vpn.v1.RuleListResponse\x12H\n" +
	"\tSaveRules\x12\x1c.awg.vpn.v1.SaveRulesRequest\x1a\x1d.awg.vpn.v1.SaveRulesResponse\x12M\n" +
	"\x0fListDomainRules\x12\x16.google.protobuf.Empty\x1a\".awg.vpn.v1.DomainRuleListResponse\x12Z\n" +
	"\x0fSaveDomainRules\x12\".awg.vpn.v1.SaveDomainRulesRequest\x1a#.awg.vpn.v1.SaveDomainRulesResponse\x12V\n" +
	"\x15ListGeositeCategories\x12\x16.google.protobuf.Empty\x1a%.awg.vpn.v1.GeositeCategoriesResponse\x12T\n" +
	"\x13ListGeoIPCategories\x12\x16.google.protobuf.Empty\x1a%.awg.vpn.v1.GeositeCategoriesResponse\x12J\n" +
	"\rUpdateGeosite\x12\x16.google.protobuf.Empty\x1a!.awg.vpn.v1.UpdateGeositeResponse\x12:\n" +
	"\tGetConfig\x12\x16.google.protobuf.Empty\x1a\x15.awg.vpn.v1.AppConfig\x12K\n" +
	"\n" +
	"SaveConfig\x12\x1d.awg.vpn.v1.SaveConfigRequest\x1a\x1e.awg.vpn.v1.SaveConfigResponse\x12B\n" +
	"\n" +
	"StreamLogs\x12\x1c.awg.vpn.v1.LogStreamRequest\x1a\x14.awg.vpn.v1.LogEntry0\x01\x12J\n" +
	"\vStreamStats\x12\x1e.awg.vpn.v1.StatsStreamRequest\x1a\x19.awg.vpn.v1.StatsSnapshot0\x01\x12P\n" +
	"\rListProcesses\x12\x1e.awg.vpn.v1.ProcessListRequest\x1a\x1f.awg.vpn.v1.ProcessListResponse\x12C\n" +
	"\fGetAutostart\x12\x16.google.protobuf.Empty\x1a\x1b.awg.vpn.v1.AutostartConfig\x12Q\n" +
	"\fSetAutostart\x12\x1f.awg.vpn.v1.SetAutostartRequest\x1a .awg.vpn.v1.SetAutostartResponse\x12Q\n" +
	"\x11ListSubscriptions\x12\x16.google.protobuf.Empty\x1a$.awg.vpn.v1.SubscriptionListResponse\x12Z\n" +
	"\x0fAddSubscription\x12\".awg.vpn.v1.AddSubscriptionRequest\x1a#.awg.vpn.v1.AddSubscriptionResponse\x12c\n" +
	"\x12RemoveSubscription\x12%.awg.vpn.v1.RemoveSubscriptionRequest\x1a&.awg.vpn.v1.RemoveSubscriptionResponse\x12f\n" +
	"\x13RefreshSubscription\x12&.awg.vpn.v1.RefreshSubscriptionRequest\x1a'.awg.vpn.v1.RefreshSubscriptionResponse\x12I\n" +
	"\x12RestoreConnections\x12\x16.google.protobuf.Empty\x1a\x1b.awg.vpn.v1.ConnectResponse\x12?\n" +
	"\bFlushDNS\x12\x16.google.protobuf.Empty\x1a\x1b.awg.vpn.v1.ConnectResponse\x12F\n" +
	"\vCheckUpdate\x12\x16.google.protobuf.Empty\x1a\x1f.awg.vpn.v1.CheckUpdateResponse\x12F\n" +
	"\vApplyUpdate\x12\x16.google.protobuf.Empty\x1a\x1f.awg.vpn.v1.ApplyUpdateResponse\x12[\n" +
	"\x18CheckConflictingServices\x12\x16.google.protobuf.Empty\x1a'.awg.vpn.v1.ConflictingServicesResponse\x12r\n" +
	"\x17StopConflictingServices\x12*.awg.vpn.v1.StopConflictingServicesRequest\x1a+.awg.vpn.v1.StopConflictingServicesResponseB!Z\x1fawg-split-tunnel/api/gen;vpnapib\x06proto3"

var (
	file_vpn_service_proto_rawDescOnce sync.Once
	file_vpn_service_proto_rawDescData []byte
)

func file_vpn_service_proto_rawDescGZIP() []byte {
	file_vpn_service_proto_rawDescOnce.Do(func() {
		file_vpn_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vpn_service_proto_rawDesc), len(file_vpn_service_proto_rawDesc)))
	})
	return file_vpn_service_proto_rawDescData
}

var file_vpn_service_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_vpn_service_proto_msgTypes = make([]protoimpl.MessageInfo, 64)
var file_vpn_service_proto_goTypes = []any{
	(TunnelState)(0),                        // 0: awg.vpn.v1.TunnelState
	(FallbackPolicy)(0),                     // 1: awg.vpn.v1.FallbackPolicy
	(LogLevel)(0),                           // 2: awg.vpn.v1.LogLevel
	(DomainAction)(0),                       // 3: awg.vpn.v1.DomainAction
	(*TunnelConfig)(nil),                    // 4: awg.vpn.v1.TunnelConfig
	(*TunnelStatus)(nil),                    // 5: awg.vpn.v1.TunnelStatus
	(*DomainRule)(nil),                      // 6: awg.vpn.v1.DomainRule
	(*Rule)(nil),                            // 7: awg.vpn.v1.Rule
	(*DNSCacheConfig)(nil),                  // 8: awg.vpn.v1.DNSCacheConfig
	(*DNSConfig)(nil),                       // 9: awg.vpn.v1.DNSConfig
	(*GlobalFilterConfig)(nil),              // 10: awg.vpn.v1.GlobalFilterConfig
	(*LogConfig)(nil),                       // 11: awg.vpn.v1.LogConfig
	(*SubscriptionConfig)(nil),              // 12: awg.vpn.v1.SubscriptionConfig
	(*SubscriptionStatus)(nil),              // 13: awg.vpn.v1.SubscriptionStatus
	(*ReconnectConfig)(nil),                 // 14: awg.vpn.v1.ReconnectConfig
	(*AppConfig)(nil),                       // 15: awg.vpn.v1.AppConfig
	(*TunnelStats)(nil),                     // 16: awg.vpn.v1.TunnelStats
	(*StatsSnapshot)(nil),                   // 17: awg.vpn.v1.StatsSnapshot
	(*LogEntry)(nil),                        // 18: awg.vpn.v1.LogEntry
	(*ProcessInfo)(nil),                     // 19: awg.vpn.v1.ProcessInfo
	(*ConnectRequest)(nil),                  // 20: awg.vpn.v1.ConnectRequest
	(*ConnectResponse)(nil),                 // 21: awg.vpn.v1.ConnectResponse
	(*DisconnectRequest)(nil),               // 22: awg.vpn.v1.DisconnectRequest
	(*DisconnectResponse)(nil),              // 23: awg.vpn.v1.DisconnectResponse
	(*AddTunnelRequest)(nil),                // 24: awg.vpn.v1.AddTunnelRequest
	(*AddTunnelResponse)(nil),               // 25: awg.vpn.v1.AddTunnelResponse
	(*RemoveTunnelRequest)(nil),             // 26: awg.vpn.v1.RemoveTunnelRequest
	(*RemoveTunnelResponse)(nil),            // 27: awg.vpn.v1.RemoveTunnelResponse
	(*UpdateTunnelRequest)(nil),             // 28: awg.vpn.v1.UpdateTunnelRequest
	(*UpdateTunnelResponse)(nil),            // 29: awg.vpn.v1.UpdateTunnelResponse
	(*GetTunnelRequest)(nil),                // 30: awg.vpn.v1.GetTunnelRequest
	(*TunnelListResponse)(nil),              // 31: awg.vpn.v1.TunnelListResponse
	(*SaveTunnelOrderRequest)(nil),          // 32: awg.vpn.v1.SaveTunnelOrderRequest
	(*SaveTunnelOrderResponse)(nil),         // 33: awg.vpn.v1.SaveTunnelOrderResponse
	(*RuleListResponse)(nil),                // 34: awg.vpn.v1.RuleListResponse
	(*SaveRulesRequest)(nil),                // 35: awg.vpn.v1.SaveRulesRequest
	(*SaveRulesResponse)(nil),               // 36: awg.vpn.v1.SaveRulesResponse
	(*DomainRuleListResponse)(nil),          // 37: awg.vpn.v1.DomainRuleListResponse
	(*SaveDomainRulesRequest)(nil),          // 38: awg.vpn.v1.SaveDomainRulesRequest
	(*SaveDomainRulesResponse)(nil),         // 39: awg.vpn.v1.SaveDomainRulesResponse
	(*GeositeCategoriesResponse)(nil),       // 40: awg.vpn.v1.GeositeCategoriesResponse
	(*UpdateGeositeResponse)(nil),           // 41: awg.vpn.v1.UpdateGeositeResponse
	(*SaveConfigRequest)(nil),               // 42: awg.vpn.v1.SaveConfigRequest
	(*SaveConfigResponse)(nil),              // 43: awg.vpn.v1.SaveConfigResponse
	(*LogStreamRequest)(nil),                // 44: awg.vpn.v1.LogStreamRequest
	(*StatsStreamRequest)(nil),              // 45: awg.vpn.v1.StatsStreamRequest
	(*ProcessListRequest)(nil),              // 46: awg.vpn.v1.ProcessListRequest
	(*ProcessListResponse)(nil),             // 47: awg.vpn.v1.ProcessListResponse
	(*SubscriptionListResponse)(nil),        // 48: awg.vpn.v1.SubscriptionListResponse
	(*AddSubscriptionRequest)(nil),          // 49: awg.vpn.v1.AddSubscriptionRequest
	(*AddSubscriptionResponse)(nil),         // 50: awg.vpn.v1.AddSubscriptionResponse
	(*RemoveSubscriptionRequest)(nil),       // 51: awg.vpn.v1.RemoveSubscriptionRequest
	(*RemoveSubscriptionResponse)(nil),      // 52: awg.vpn.v1.RemoveSubscriptionResponse
	(*RefreshSubscriptionRequest)(nil),      // 53: awg.vpn.v1.RefreshSubscriptionRequest
	(*RefreshSubscriptionResponse)(nil),     // 54: awg.vpn.v1.RefreshSubscriptionResponse
	(*ServiceStatus)(nil),                   // 55: awg.vpn.v1.ServiceStatus
	(*UpdateInfo)(nil),                      // 56: awg.vpn.v1.UpdateInfo
	(*CheckUpdateResponse)(nil),             // 57: awg.vpn.v1.CheckUpdateResponse
	(*ApplyUpdateResponse)(nil),             // 58: awg.vpn.v1.ApplyUpdateResponse
	(*AutostartConfig)(nil),                 // 59: awg.vpn.v1.AutostartConfig
	(*SetAutostartRequest)(nil),             // 60: awg.vpn.v1.SetAutostartRequest
	(*SetAutostartResponse)(nil),            // 61: awg.vpn.v1.SetAutostartResponse
	(*ConflictingService)(nil),              // 62: awg.vpn.v1.ConflictingService
	(*ConflictingServicesResponse)(nil),     // 63: awg.vpn.v1.ConflictingServicesResponse
	(*StopConflictingServicesRequest)(nil),  // 64: awg.vpn.v1.StopConflictingServicesRequest
	(*StopConflictingServicesResponse)(nil), // 65: awg.vpn.v1.StopConflictingServicesResponse
	nil,                                     // 66: awg.vpn.v1.TunnelConfig.SettingsEntry
	nil,                                     // 67: awg.vpn.v1.LogConfig.ComponentsEntry
	(*timestamppb.Timestamp)(nil),           // 68: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),                   // 69: google.protobuf.Empty
}
var file_vpn_service_proto_depIdxs = []int32{
	66, // 0: awg.vpn.v1.TunnelConfig.settings:type_name -> awg.vpn.v1.TunnelConfig.SettingsEntry
	4,  // 1: awg.vpn.v1.TunnelStatus.config:type_name -> awg.vpn.v1.TunnelConfig
	0,  // 2: awg.vpn.v1.TunnelStatus.state:type_name -> awg.vpn.v1.TunnelState
	3,  // 3: awg.vpn.v1.DomainRule.action:type_name -> awg.vpn.v1.DomainAction
	1,  // 4: awg.vpn.v1.Rule.fallback:type_name -> awg.vpn.v1.FallbackPolicy
	8,  // 5: awg.vpn.v1.DNSConfig.cache:type_name -> awg.vpn.v1.DNSCacheConfig
	67, // 6: awg.vpn.v1.LogConfig.components:type_name -> awg.vpn.v1.LogConfig.ComponentsEntry
	12, // 7: awg.vpn.v1.SubscriptionStatus.config:type_name -> awg.vpn.v1.SubscriptionConfig
	10, // 8: awg.vpn.v1.AppConfig.global:type_name -> awg.vpn.v1.GlobalFilterConfig
	4,  // 9: awg.vpn.v1.AppConfig.tunnels:type_name -> awg.vpn.v1.TunnelConfig
	7,  // 10: awg.vpn.v1.AppConfig.rules:type_name -> awg.vpn.v1.Rule
	9,  // 11: awg.vpn.v1.AppConfig.dns:type_name -> awg.vpn.v1.DNSConfig
	11, // 12: awg.vpn.v1.AppConfig.logging:type_name -> awg.vpn.v1.LogConfig
	6,  // 13: awg.vpn.v1.AppConfig.domain_rules:type_name -> awg.vpn.v1.DomainRule
	12, // 14: awg.vpn.v1.AppConfig.subscriptions:type_name -> awg.vpn.v1.SubscriptionConfig
	14, // 15: awg.vpn.v1.AppConfig.reconnect:type_name -> awg.vpn.v1.ReconnectConfig
	0,  // 16: awg.vpn.v1.TunnelStats.state:type_name -> awg.vpn.v1.TunnelState
	68, // 17: awg.vpn.v1.TunnelStats.last_handshake:type_name -> google.protobuf.Timestamp
	16, // 18: awg.vpn.v1.StatsSnapshot.tunnels:type_name -> awg.vpn.v1.TunnelStats
	68, // 19: awg.vpn.v1.StatsSnapshot.timestamp:type_name -> google.protobuf.Timestamp
	68, // 20: awg.vpn.v1.LogEntry.timestamp:type_name -> google.protobuf.Timestamp
	2,  // 21: awg.vpn.v1.LogEntry.level:type_name -> awg.vpn.v1.LogLevel
	4,  // 22: awg.vpn.v1.AddTunnelRequest.config:type_name -> awg.vpn.v1.TunnelConfig
	4,  // 23: awg.vpn.v1.UpdateTunnelRequest.config:type_name -> awg.vpn.v1.TunnelConfig
	5,  // 24: awg.vpn.v1.TunnelListResponse.tunnels:type_name -> awg.vpn.v1.TunnelStatus
	7,  // 25: awg.vpn.v1.RuleListResponse.rules:type_name -> awg.vpn.v1.Rule
	7,  // 26: awg.vpn.v1.SaveRulesRequest.rules:type_name -> awg.vpn.v1.Rule
	6,  // 27: awg.vpn.v1.DomainRuleListResponse.rules:type_name -> awg.vpn.v1.DomainRule
	6,  // 28: awg.vpn.v1.SaveDomainRulesRequest.rules:type_name -> awg.vpn.v1.DomainRule
	15, // 29: awg.vpn.v1.SaveConfigRequest.config:type_name -> awg.vpn.v1.AppConfig
	2,  // 30: awg.vpn.v1.LogStreamRequest.min_level:type_name -> awg.vpn.v1.LogLevel
	19, // 31: awg.vpn.v1.ProcessListResponse.processes:type_name -> awg.vpn.v1.ProcessInfo
	13, // 32: awg.vpn.v1.SubscriptionListResponse.subscriptions:type_name -> awg.vpn.v1.SubscriptionStatus
	12, // 33: awg.vpn.v1.AddSubscriptionRequest.config:type_name -> awg.vpn.v1.SubscriptionConfig
	56, // 34: awg.vpn.v1.CheckUpdateResponse.info:type_name -> awg.vpn.v1.UpdateInfo
	59, // 35: awg.vpn.v1.SetAutostartRequest.config:type_name -> awg.vpn.v1.AutostartConfig
	62, // 36: awg.vpn.v1.ConflictingServicesResponse.services:type_name -> awg.vpn.v1.ConflictingService
	69, // 37: awg.vpn.v1.VPNService.GetStatus:input_type -> google.protobuf.Empty
	69, // 38: awg.vpn.v1.VPNService.Shutdown:input_type -> google.protobuf.Empty
	69, // 39: awg.vpn.v1.VPNService.ListTunnels:input_type -> google.protobuf.Empty
	30, // 40: awg.vpn.v1.VPNService.GetTunnel:input_type -> awg.vpn.v1.GetTunnelRequest
	24, // 41: awg.vpn.v1.VPNService.AddTunnel:input_type -> awg.vpn.v1.AddTunnelRequest
	26, // 42: awg.vpn.v1.VPNService.RemoveTunnel:input_type -> awg.vpn.v1.RemoveTunnelRequest
	28, // 43: awg.vpn.v1.VPNService.UpdateTunnel:input_type -> awg.vpn.v1.UpdateTunnelRequest
	20, // 44: awg.vpn.v1.VPNService.Connect:input_type -> awg.vpn.v1.ConnectRequest
	22, // 45: awg.vpn.v1.VPNService.Disconnect:input_type -> awg.vpn.v1.DisconnectRequest
	20, // 46: awg.vpn.v1.VPNService.RestartTunnel:input_type -> awg.vpn.v1.ConnectRequest
	32, // 47: awg.vpn.v1.VPNService.SaveTunnelOrder:input_type -> awg.vpn.v1.SaveTunnelOrderRequest
	69, // 48: awg.vpn.v1.VPNService.ListRules:input_type -> google.protobuf.Empty
	35, // 49: awg.vpn.v1.VPNService.SaveRules:input_type -> awg.vpn.v1.SaveRulesRequest
	69, // 50: awg.vpn.v1.VPNService.ListDomainRules:input_type -> google.protobuf.Empty
	38, // 51: awg.vpn.v1.VPNService.SaveDomainRules:input_type -> awg.vpn.v1.SaveDomainRulesRequest
	69, // 52: awg.vpn.v1.VPNService.ListGeositeCategories:input_type -> google.protobuf.Empty
	69, // 53: awg.vpn.v1.VPNService.ListGeoIPCategories:input_type -> google.protobuf.Empty
	69, // 54: awg.vpn.v1.VPNService.UpdateGeosite:input_type -> google.protobuf.Empty
	69, // 55: awg.vpn.v1.VPNService.GetConfig:input_type -> google.protobuf.Empty
	42, // 56: awg.vpn.v1.VPNService.SaveConfig:input_type -> awg.vpn.v1.SaveConfigRequest
	44, // 57: awg.vpn.v1.VPNService.StreamLogs:input_type -> awg.vpn.v1.LogStreamRequest
	45, // 58: awg.vpn.v1.VPNService.StreamStats:input_type -> awg.vpn.v1.StatsStreamRequest
	46, // 59: awg.vpn.v1.VPNService.ListProcesses:input_type -> awg.vpn.v1.ProcessListRequest
	69, // 60: awg.vpn.v1.VPNService.GetAutostart:input_type -> google.protobuf.Empty
	60, // 61: awg.vpn.v1.VPNService.SetAutostart:input_type -> awg.vpn.v1.SetAutostartRequest
	69, // 62: awg.vpn.v1.VPNService.ListSubscriptions:input_type -> google.protobuf.Empty
	49, // 63: awg.vpn.v1.VPNService.AddSubscription:input_type -> awg.vpn.v1.AddSubscriptionRequest
	51, // 64: awg.vpn.v1.VPNService.RemoveSubscription:input_type -> awg.vpn.v1.RemoveSubscriptionRequest
	53, // 65: awg.vpn.v1.VPNService.RefreshSubscription:input_type -> awg.vpn.v1.RefreshSubscriptionRequest
	69, // 66: awg.vpn.v1.VPNService.RestoreConnections:input_type -> google.protobuf.Empty
	69, // 67: awg.vpn.v1.VPNService.FlushDNS:input_type -> google.protobuf.Empty
	69, // 68: awg.vpn.v1.VPNService.CheckUpdate:input_type -> google.protobuf.Empty
	69, // 69: awg.vpn.v1.VPNService.ApplyUpdate:input_type -> google.protobuf.Empty
	69, // 70: awg.vpn.v1.VPNService.CheckConflictingServices:input_type -> google.protobuf.Empty
	64, // 71: awg.vpn.v1.VPNService.StopConflictingServices:input_type -> awg.vpn.v1.StopConflictingServicesRequest
	55, // 72: awg.vpn.v1.VPNService.GetStatus:output_type -> awg.vpn.v1.ServiceStatus
	69, // 73: awg.vpn.v1.VPNService.Shutdown:output_type -> google.protobuf.Empty
	31, // 74: awg.vpn.v1.VPNService.ListTunnels:output_type -> awg.vpn.v1.TunnelListResponse
	5,  // 75: awg.vpn.v1.VPNService.GetTunnel:output_type -> awg.vpn.v1.TunnelStatus
	25, // 76: awg.vpn.v1.VPNService.AddTunnel:output_type -> awg.vpn.v1.AddTunnelResponse
	27, // 77: awg.vpn.v1.VPNService.RemoveTunnel:output_type -> awg.vpn.v1.RemoveTunnelResponse
	29, // 78: awg.vpn.v1.VPNService.UpdateTunnel:output_type -> awg.vpn.v1.UpdateTunnelResponse
	21, // 79: awg.vpn.v1.VPNService.Connect:output_type -> awg.vpn.v1.ConnectResponse
	23, // 80: awg.vpn.v1.VPNService.Disconnect:output_type -> awg.vpn.v1.DisconnectResponse
	21, // 81: awg.vpn.v1.VPNService.RestartTunnel:output_type -> awg.vpn.v1.ConnectResponse
	33, // 82: awg.vpn.v1.VPNService.SaveTunnelOrder:output_type -> awg.vpn.v1.SaveTunnelOrderResponse
	34, // 83: awg.vpn.v1.VPNService.ListRules:output_type -> awg.vpn.v1.RuleListResponse
	36, // 84: awg.vpn.v1.VPNService.SaveRules:output_type -> awg.vpn.v1.SaveRulesResponse
	37, // 85: awg.vpn.v1.VPNService.ListDomainRules:output_type -> awg.vpn.v1.DomainRuleListResponse
	39, // 86: awg.vpn.v1.VPNService.SaveDomainRules:output_type -> awg.vpn.v1.SaveDomainRulesResponse
	40, // 87: awg.vpn.v1.VPNService.ListGeositeCategories:output_type -> awg.vpn.v1.GeositeCategoriesResponse
	40, // 88: awg.vpn.v1.VPNService.ListGeoIPCategories:output_type -> awg.vpn.v1.GeositeCategoriesResponse
	41, // 89: awg.vpn.v1.VPNService.UpdateGeosite:output_type -> awg.vpn.v1.UpdateGeositeResponse
	15, // 90: awg.vpn.v1.VPNService.GetConfig:output_type -> awg.vpn.v1.AppConfig
	43, // 91: awg.vpn.v1.VPNService.SaveConfig:output_type -> awg.vpn.v1.SaveConfigResponse
	18, // 92: awg.vpn.v1.VPNService.StreamLogs:output_type -> awg.vpn.v1.LogEntry
	17, // 93: awg.vpn.v1.VPNService.StreamStats:output_type -> awg.vpn.v1.StatsSnapshot
	47, // 94: awg.vpn.v1.VPNService.ListProcesses:output_type -> awg.vpn.v1.ProcessListResponse
	59, // 95: awg.vpn.v1.VPNService.GetAutostart:output_type -> awg.vpn.v1.AutostartConfig
	61, // 96: awg.vpn.v1.VPNService.SetAutostart:output_type -> awg.vpn.v1.SetAutostartResponse
	48, // 97: awg.vpn.v1.VPNService.ListSubscriptions:output_type -> awg.vpn.v1.SubscriptionListResponse
	50, // 98: awg.vpn.v1.VPNService.AddSubscription:output_type -> awg.vpn.v1.AddSubscriptionResponse
	52, // 99: awg.vpn.v1.VPNService.RemoveSubscription:output_type -> awg.vpn.v1.RemoveSubscriptionResponse
	54, // 100: awg.vpn.v1.VPNService.RefreshSubscription:output_type -> awg.vpn.v1.RefreshSubscriptionResponse
	21, // 101: awg.vpn.v1.VPNService.RestoreConnections:output_type -> awg.vpn.v1.ConnectResponse
	21, // 102: awg.vpn.v1.VPNService.FlushDNS:output_type -> awg.vpn.v1.ConnectResponse
	57, // 103: awg.vpn.v1.VPNService.CheckUpdate:output_type -> awg.vpn.v1.CheckUpdateResponse
	58, // 104: awg.vpn.v1.VPNService.ApplyUpdate:output_type -> awg.vpn.v1.ApplyUpdateResponse
	63, // 105: awg.vpn.v1.VPNService.CheckConflictingServices:output_type -> awg.vpn.v1.ConflictingServicesResponse
	65, // 106: awg.vpn.v1.VPNService.StopConflictingServices:output_type -> awg.vpn.v1.StopConflictingServicesResponse
	72, // [72:107] is the sub-list for method output_type
	37, // [37:72] is the sub-list for method input_type
	37, // [37:37] is the sub-list for extension type_name
	37, // [37:37] is the sub-list for extension extendee
	0,  // [0:37] is the sub-list for field type_name
}

func init() { file_vpn_service_proto_init() }
func file_vpn_service_proto_init() {
	if File_vpn_service_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vpn_service_proto_rawDesc), len(file_vpn_service_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   64,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_vpn_service_proto_goTypes,
		DependencyIndexes: file_vpn_service_proto_depIdxs,
		EnumInfos:         file_vpn_service_proto_enumTypes,
		MessageInfos:      file_vpn_service_proto_msgTypes,
	}.Build()
	File_vpn_service_proto = out.File
	file_vpn_service_proto_goTypes = nil
	file_vpn_service_proto_depIdxs = nil
}
