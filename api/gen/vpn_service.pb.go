// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.5
// source: vpn_service.proto

package vpnapi

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TunnelState int32

const (
	TunnelState_TUNNEL_STATE_DOWN       TunnelState = 0
	TunnelState_TUNNEL_STATE_CONNECTING TunnelState = 1
	TunnelState_TUNNEL_STATE_UP         TunnelState = 2
	TunnelState_TUNNEL_STATE_ERROR      TunnelState = 3
)

// Enum value maps for TunnelState.
var (
	TunnelState_name = map[int32]string{
		0: "TUNNEL_STATE_DOWN",
		1: "TUNNEL_STATE_CONNECTING",
		2: "TUNNEL_STATE_UP",
		3: "TUNNEL_STATE_ERROR",
	}
	TunnelState_value = map[string]int32{
		"TUNNEL_STATE_DOWN":       0,
		"TUNNEL_STATE_CONNECTING": 1,
		"TUNNEL_STATE_UP":         2,
		"TUNNEL_STATE_ERROR":      3,
	}
)

func (x TunnelState) Enum() *TunnelState {
	p := new(TunnelState)
	*p = x
	return p
}

func (x TunnelState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelState) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[0].Descriptor()
}

func (TunnelState) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[0]
}

func (x TunnelState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelState.Descriptor instead.
func (TunnelState) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{0}
}

type FallbackPolicy int32

const (
	FallbackPolicy_FALLBACK_ALLOW_DIRECT FallbackPolicy = 0
	FallbackPolicy_FALLBACK_BLOCK        FallbackPolicy = 1
	FallbackPolicy_FALLBACK_DROP         FallbackPolicy = 2
)

// Enum value maps for FallbackPolicy.
var (
	FallbackPolicy_name = map[int32]string{
		0: "FALLBACK_ALLOW_DIRECT",
		1: "FALLBACK_BLOCK",
		2: "FALLBACK_DROP",
	}
	FallbackPolicy_value = map[string]int32{
		"FALLBACK_ALLOW_DIRECT": 0,
		"FALLBACK_BLOCK":        1,
		"FALLBACK_DROP":         2,
	}
)

func (x FallbackPolicy) Enum() *FallbackPolicy {
	p := new(FallbackPolicy)
	*p = x
	return p
}

func (x FallbackPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FallbackPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[1].Descriptor()
}

func (FallbackPolicy) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[1]
}

func (x FallbackPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FallbackPolicy.Descriptor instead.
func (FallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{1}
}

type LogLevel int32

const (
	LogLevel_LOG_LEVEL_DEBUG LogLevel = 0
	LogLevel_LOG_LEVEL_INFO  LogLevel = 1
	LogLevel_LOG_LEVEL_WARN  LogLevel = 2
	LogLevel_LOG_LEVEL_ERROR LogLevel = 3
	LogLevel_LOG_LEVEL_OFF   LogLevel = 4
)

// Enum value maps for LogLevel.
var (
	LogLevel_name = map[int32]string{
		0: "LOG_LEVEL_DEBUG",
		1: "LOG_LEVEL_INFO",
		2: "LOG_LEVEL_WARN",
		3: "LOG_LEVEL_ERROR",
		4: "LOG_LEVEL_OFF",
	}
	LogLevel_value = map[string]int32{
		"LOG_LEVEL_DEBUG": 0,
		"LOG_LEVEL_INFO":  1,
		"LOG_LEVEL_WARN":  2,
		"LOG_LEVEL_ERROR": 3,
		"LOG_LEVEL_OFF":   4,
	}
)

func (x LogLevel) Enum() *LogLevel {
	p := new(LogLevel)
	*p = x
	return p
}

func (x LogLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_service_proto_enumTypes[2].Descriptor()
}

func (LogLevel) Type() protoreflect.EnumType {
	return &file_vpn_service_proto_enumTypes[2]
}

func (x LogLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogLevel.Descriptor instead.
func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{2}
}

type TunnelConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Protocol       string                 `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Name           string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Settings       map[string]string      `protobuf:"bytes,4,rep,name=settings,proto3" json:"settings,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AllowedIps     []string               `protobuf:"bytes,5,rep,name=allowed_ips,json=allowedIps,proto3" json:"allowed_ips,omitempty"`
	DisallowedIps  []string               `protobuf:"bytes,6,rep,name=disallowed_ips,json=disallowedIps,proto3" json:"disallowed_ips,omitempty"`
	DisallowedApps []string               `protobuf:"bytes,7,rep,name=disallowed_apps,json=disallowedApps,proto3" json:"disallowed_apps,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TunnelConfig) Reset() {
	*x = TunnelConfig{}
	mi := &file_vpn_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelConfig) ProtoMessage() {}

func (x *TunnelConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelConfig.ProtoReflect.Descriptor instead.
func (*TunnelConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{0}
}

func (x *TunnelConfig) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TunnelConfig) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *TunnelConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TunnelConfig) GetSettings() map[string]string {
	if x != nil {
		return x.Settings
	}
	return nil
}

func (x *TunnelConfig) GetAllowedIps() []string {
	if x != nil {
		return x.AllowedIps
	}
	return nil
}

func (x *TunnelConfig) GetDisallowedIps() []string {
	if x != nil {
		return x.DisallowedIps
	}
	return nil
}

func (x *TunnelConfig) GetDisallowedApps() []string {
	if x != nil {
		return x.DisallowedApps
	}
	return nil
}

type TunnelStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Config        *TunnelConfig          `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	State         TunnelState            `protobuf:"varint,3,opt,name=state,proto3,enum=awg.vpn.v1.TunnelState" json:"state,omitempty"`
	Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`                          // error message if state == ERROR
	AdapterIp     string                 `protobuf:"bytes,5,opt,name=adapter_ip,json=adapterIp,proto3" json:"adapter_ip,omitempty"` // VPN adapter IP (e.g. "10.8.1.2")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelStatus) Reset() {
	*x = TunnelStatus{}
	mi := &file_vpn_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelStatus) ProtoMessage() {}

func (x *TunnelStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelStatus.ProtoReflect.Descriptor instead.
func (*TunnelStatus) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{1}
}

func (x *TunnelStatus) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TunnelStatus) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *TunnelStatus) GetState() TunnelState {
	if x != nil {
		return x.State
	}
	return TunnelState_TUNNEL_STATE_DOWN
}

func (x *TunnelStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *TunnelStatus) GetAdapterIp() string {
	if x != nil {
		return x.AdapterIp
	}
	return ""
}

type Rule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pattern       string                 `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	TunnelId      string                 `protobuf:"bytes,2,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // empty for drop-only rules
	Fallback      FallbackPolicy         `protobuf:"varint,3,opt,name=fallback,proto3,enum=awg.vpn.v1.FallbackPolicy" json:"fallback,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Rule) Reset() {
	*x = Rule{}
	mi := &file_vpn_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{2}
}

func (x *Rule) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *Rule) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *Rule) GetFallback() FallbackPolicy {
	if x != nil {
		return x.Fallback
	}
	return FallbackPolicy_FALLBACK_ALLOW_DIRECT
}

type DNSCacheConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MaxSize       int32                  `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	MinTtl        string                 `protobuf:"bytes,3,opt,name=min_ttl,json=minTtl,proto3" json:"min_ttl,omitempty"` // duration string, e.g. "30s"
	MaxTtl        string                 `protobuf:"bytes,4,opt,name=max_ttl,json=maxTtl,proto3" json:"max_ttl,omitempty"` // duration string, e.g. "5m"
	NegTtl        string                 `protobuf:"bytes,5,opt,name=neg_ttl,json=negTtl,proto3" json:"neg_ttl,omitempty"` // duration string, e.g. "60s"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSCacheConfig) Reset() {
	*x = DNSCacheConfig{}
	mi := &file_vpn_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSCacheConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSCacheConfig) ProtoMessage() {}

func (x *DNSCacheConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSCacheConfig.ProtoReflect.Descriptor instead.
func (*DNSCacheConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{3}
}

func (x *DNSCacheConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DNSCacheConfig) GetMaxSize() int32 {
	if x != nil {
		return x.MaxSize
	}
	return 0
}

func (x *DNSCacheConfig) GetMinTtl() string {
	if x != nil {
		return x.MinTtl
	}
	return ""
}

func (x *DNSCacheConfig) GetMaxTtl() string {
	if x != nil {
		return x.MaxTtl
	}
	return ""
}

func (x *DNSCacheConfig) GetNegTtl() string {
	if x != nil {
		return x.NegTtl
	}
	return ""
}

type DNSConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // tunnel for DNS routing
	Servers       []string               `protobuf:"bytes,2,rep,name=servers,proto3" json:"servers,omitempty"`
	Cache         *DNSCacheConfig        `protobuf:"bytes,3,opt,name=cache,proto3" json:"cache,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSConfig) Reset() {
	*x = DNSConfig{}
	mi := &file_vpn_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSConfig) ProtoMessage() {}

func (x *DNSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.
func (*DNSConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{4}
}

func (x *DNSConfig) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *DNSConfig) GetServers() []string {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *DNSConfig) GetCache() *DNSCacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

type GlobalFilterConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AllowedIps     []string               `protobuf:"bytes,1,rep,name=allowed_ips,json=allowedIps,proto3" json:"allowed_ips,omitempty"`
	DisallowedIps  []string               `protobuf:"bytes,2,rep,name=disallowed_ips,json=disallowedIps,proto3" json:"disallowed_ips,omitempty"`
	DisallowedApps []string               `protobuf:"bytes,3,rep,name=disallowed_apps,json=disallowedApps,proto3" json:"disallowed_apps,omitempty"`
	DisableLocal   bool                   `protobuf:"varint,4,opt,name=disable_local,json=disableLocal,proto3" json:"disable_local,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GlobalFilterConfig) Reset() {
	*x = GlobalFilterConfig{}
	mi := &file_vpn_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobalFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalFilterConfig) ProtoMessage() {}

func (x *GlobalFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalFilterConfig.ProtoReflect.Descriptor instead.
func (*GlobalFilterConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{5}
}

func (x *GlobalFilterConfig) GetAllowedIps() []string {
	if x != nil {
		return x.AllowedIps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisallowedIps() []string {
	if x != nil {
		return x.DisallowedIps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisallowedApps() []string {
	if x != nil {
		return x.DisallowedApps
	}
	return nil
}

func (x *GlobalFilterConfig) GetDisableLocal() bool {
	if x != nil {
		return x.DisableLocal
	}
	return false
}

type LogConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Level         string                 `protobuf:"bytes,1,opt,name=level,proto3" json:"level,omitempty"`                                                                                     // "debug", "info", "warn", "error", "off"
	Components    map[string]string      `protobuf:"bytes,2,rep,name=components,proto3" json:"components,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // per-component overrides
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogConfig) Reset() {
	*x = LogConfig{}
	mi := &file_vpn_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogConfig) ProtoMessage() {}

func (x *LogConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogConfig.ProtoReflect.Descriptor instead.
func (*LogConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{6}
}

func (x *LogConfig) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *LogConfig) GetComponents() map[string]string {
	if x != nil {
		return x.Components
	}
	return nil
}

type AppConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Global        *GlobalFilterConfig    `protobuf:"bytes,1,opt,name=global,proto3" json:"global,omitempty"`
	Tunnels       []*TunnelConfig        `protobuf:"bytes,2,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	Rules         []*Rule                `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	Dns           *DNSConfig             `protobuf:"bytes,4,opt,name=dns,proto3" json:"dns,omitempty"`
	Logging       *LogConfig             `protobuf:"bytes,5,opt,name=logging,proto3" json:"logging,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppConfig) Reset() {
	*x = AppConfig{}
	mi := &file_vpn_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppConfig) ProtoMessage() {}

func (x *AppConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppConfig.ProtoReflect.Descriptor instead.
func (*AppConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{7}
}

func (x *AppConfig) GetGlobal() *GlobalFilterConfig {
	if x != nil {
		return x.Global
	}
	return nil
}

func (x *AppConfig) GetTunnels() []*TunnelConfig {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

func (x *AppConfig) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *AppConfig) GetDns() *DNSConfig {
	if x != nil {
		return x.Dns
	}
	return nil
}

func (x *AppConfig) GetLogging() *LogConfig {
	if x != nil {
		return x.Logging
	}
	return nil
}

type TunnelStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	State         TunnelState            `protobuf:"varint,2,opt,name=state,proto3,enum=awg.vpn.v1.TunnelState" json:"state,omitempty"`
	BytesTx       int64                  `protobuf:"varint,3,opt,name=bytes_tx,json=bytesTx,proto3" json:"bytes_tx,omitempty"`           // total bytes sent
	BytesRx       int64                  `protobuf:"varint,4,opt,name=bytes_rx,json=bytesRx,proto3" json:"bytes_rx,omitempty"`           // total bytes received
	SpeedTx       int64                  `protobuf:"varint,5,opt,name=speed_tx,json=speedTx,proto3" json:"speed_tx,omitempty"`           // bytes/sec upload
	SpeedRx       int64                  `protobuf:"varint,6,opt,name=speed_rx,json=speedRx,proto3" json:"speed_rx,omitempty"`           // bytes/sec download
	PacketLoss    float64                `protobuf:"fixed64,7,opt,name=packet_loss,json=packetLoss,proto3" json:"packet_loss,omitempty"` // 0.0-1.0, fraction of lost packets
	LatencyMs     int64                  `protobuf:"varint,8,opt,name=latency_ms,json=latencyMs,proto3" json:"latency_ms,omitempty"`     // RTT in milliseconds
	LastHandshake *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_handshake,json=lastHandshake,proto3" json:"last_handshake,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelStats) Reset() {
	*x = TunnelStats{}
	mi := &file_vpn_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelStats) ProtoMessage() {}

func (x *TunnelStats) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelStats.ProtoReflect.Descriptor instead.
func (*TunnelStats) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{8}
}

func (x *TunnelStats) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

func (x *TunnelStats) GetState() TunnelState {
	if x != nil {
		return x.State
	}
	return TunnelState_TUNNEL_STATE_DOWN
}

func (x *TunnelStats) GetBytesTx() int64 {
	if x != nil {
		return x.BytesTx
	}
	return 0
}

func (x *TunnelStats) GetBytesRx() int64 {
	if x != nil {
		return x.BytesRx
	}
	return 0
}

func (x *TunnelStats) GetSpeedTx() int64 {
	if x != nil {
		return x.SpeedTx
	}
	return 0
}

func (x *TunnelStats) GetSpeedRx() int64 {
	if x != nil {
		return x.SpeedRx
	}
	return 0
}

func (x *TunnelStats) GetPacketLoss() float64 {
	if x != nil {
		return x.PacketLoss
	}
	return 0
}

func (x *TunnelStats) GetLatencyMs() int64 {
	if x != nil {
		return x.LatencyMs
	}
	return 0
}

func (x *TunnelStats) GetLastHandshake() *timestamppb.Timestamp {
	if x != nil {
		return x.LastHandshake
	}
	return nil
}

type StatsSnapshot struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tunnels       []*TunnelStats         `protobuf:"bytes,1,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsSnapshot) Reset() {
	*x = StatsSnapshot{}
	mi := &file_vpn_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsSnapshot) ProtoMessage() {}

func (x *StatsSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsSnapshot.ProtoReflect.Descriptor instead.
func (*StatsSnapshot) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{9}
}

func (x *StatsSnapshot) GetTunnels() []*TunnelStats {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

func (x *StatsSnapshot) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

type LogEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Level         LogLevel               `protobuf:"varint,2,opt,name=level,proto3,enum=awg.vpn.v1.LogLevel" json:"level,omitempty"`
	Tag           string                 `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"` // "[Core]", "[Gateway]", etc.
	Message       string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogEntry) Reset() {
	*x = LogEntry{}
	mi := &file_vpn_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogEntry) ProtoMessage() {}

func (x *LogEntry) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{10}
}

func (x *LogEntry) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *LogEntry) GetLevel() LogLevel {
	if x != nil {
		return x.Level
	}
	return LogLevel_LOG_LEVEL_DEBUG
}

func (x *LogEntry) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *LogEntry) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ProcessInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pid           uint32                 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"` // exe file name
	Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"` // full exe path
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessInfo) Reset() {
	*x = ProcessInfo{}
	mi := &file_vpn_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessInfo) ProtoMessage() {}

func (x *ProcessInfo) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessInfo.ProtoReflect.Descriptor instead.
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{11}
}

func (x *ProcessInfo) GetPid() uint32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *ProcessInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ProcessInfo) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type ConnectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // specific tunnel, or empty for all
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	mi := &file_vpn_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{12}
}

func (x *ConnectRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type ConnectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectResponse) Reset() {
	*x = ConnectResponse{}
	mi := &file_vpn_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectResponse) ProtoMessage() {}

func (x *ConnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{13}
}

func (x *ConnectResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ConnectResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type DisconnectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // specific tunnel, or empty for all
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectRequest) Reset() {
	*x = DisconnectRequest{}
	mi := &file_vpn_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectRequest) ProtoMessage() {}

func (x *DisconnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectRequest.ProtoReflect.Descriptor instead.
func (*DisconnectRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{14}
}

func (x *DisconnectRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type DisconnectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectResponse) Reset() {
	*x = DisconnectResponse{}
	mi := &file_vpn_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectResponse) ProtoMessage() {}

func (x *DisconnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectResponse.ProtoReflect.Descriptor instead.
func (*DisconnectResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{15}
}

func (x *DisconnectResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DisconnectResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type AddTunnelRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Config         *TunnelConfig          `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	ConfigFileData []byte                 `protobuf:"bytes,2,opt,name=config_file_data,json=configFileData,proto3" json:"config_file_data,omitempty"` // raw .conf file content (for AWG)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AddTunnelRequest) Reset() {
	*x = AddTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddTunnelRequest) ProtoMessage() {}

func (x *AddTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddTunnelRequest.ProtoReflect.Descriptor instead.
func (*AddTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{16}
}

func (x *AddTunnelRequest) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *AddTunnelRequest) GetConfigFileData() []byte {
	if x != nil {
		return x.ConfigFileData
	}
	return nil
}

type AddTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddTunnelResponse) Reset() {
	*x = AddTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddTunnelResponse) ProtoMessage() {}

func (x *AddTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddTunnelResponse.ProtoReflect.Descriptor instead.
func (*AddTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{17}
}

func (x *AddTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AddTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RemoveTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveTunnelRequest) Reset() {
	*x = RemoveTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveTunnelRequest) ProtoMessage() {}

func (x *RemoveTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveTunnelRequest.ProtoReflect.Descriptor instead.
func (*RemoveTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{18}
}

func (x *RemoveTunnelRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type RemoveTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveTunnelResponse) Reset() {
	*x = RemoveTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveTunnelResponse) ProtoMessage() {}

func (x *RemoveTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveTunnelResponse.ProtoReflect.Descriptor instead.
func (*RemoveTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{19}
}

func (x *RemoveTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RemoveTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type UpdateTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *TunnelConfig          `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTunnelRequest) Reset() {
	*x = UpdateTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTunnelRequest) ProtoMessage() {}

func (x *UpdateTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTunnelRequest.ProtoReflect.Descriptor instead.
func (*UpdateTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{20}
}

func (x *UpdateTunnelRequest) GetConfig() *TunnelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type UpdateTunnelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTunnelResponse) Reset() {
	*x = UpdateTunnelResponse{}
	mi := &file_vpn_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTunnelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTunnelResponse) ProtoMessage() {}

func (x *UpdateTunnelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTunnelResponse.ProtoReflect.Descriptor instead.
func (*UpdateTunnelResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{21}
}

func (x *UpdateTunnelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateTunnelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type GetTunnelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelId      string                 `protobuf:"bytes,1,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTunnelRequest) Reset() {
	*x = GetTunnelRequest{}
	mi := &file_vpn_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTunnelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTunnelRequest) ProtoMessage() {}

func (x *GetTunnelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTunnelRequest.ProtoReflect.Descriptor instead.
func (*GetTunnelRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{22}
}

func (x *GetTunnelRequest) GetTunnelId() string {
	if x != nil {
		return x.TunnelId
	}
	return ""
}

type TunnelListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tunnels       []*TunnelStatus        `protobuf:"bytes,1,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelListResponse) Reset() {
	*x = TunnelListResponse{}
	mi := &file_vpn_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelListResponse) ProtoMessage() {}

func (x *TunnelListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelListResponse.ProtoReflect.Descriptor instead.
func (*TunnelListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{23}
}

func (x *TunnelListResponse) GetTunnels() []*TunnelStatus {
	if x != nil {
		return x.Tunnels
	}
	return nil
}

type RuleListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*Rule                `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RuleListResponse) Reset() {
	*x = RuleListResponse{}
	mi := &file_vpn_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RuleListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuleListResponse) ProtoMessage() {}

func (x *RuleListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuleListResponse.ProtoReflect.Descriptor instead.
func (*RuleListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{24}
}

func (x *RuleListResponse) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveRulesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*Rule                `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveRulesRequest) Reset() {
	*x = SaveRulesRequest{}
	mi := &file_vpn_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveRulesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveRulesRequest) ProtoMessage() {}

func (x *SaveRulesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveRulesRequest.ProtoReflect.Descriptor instead.
func (*SaveRulesRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{25}
}

func (x *SaveRulesRequest) GetRules() []*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type SaveRulesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveRulesResponse) Reset() {
	*x = SaveRulesResponse{}
	mi := &file_vpn_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveRulesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveRulesResponse) ProtoMessage() {}

func (x *SaveRulesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveRulesResponse.ProtoReflect.Descriptor instead.
func (*SaveRulesResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{26}
}

func (x *SaveRulesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveRulesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type SaveConfigRequest struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Config             *AppConfig             `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	RestartIfConnected bool                   `protobuf:"varint,2,opt,name=restart_if_connected,json=restartIfConnected,proto3" json:"restart_if_connected,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SaveConfigRequest) Reset() {
	*x = SaveConfigRequest{}
	mi := &file_vpn_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveConfigRequest) ProtoMessage() {}

func (x *SaveConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveConfigRequest.ProtoReflect.Descriptor instead.
func (*SaveConfigRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{27}
}

func (x *SaveConfigRequest) GetConfig() *AppConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *SaveConfigRequest) GetRestartIfConnected() bool {
	if x != nil {
		return x.RestartIfConnected
	}
	return false
}

type SaveConfigResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Restarted     bool                   `protobuf:"varint,3,opt,name=restarted,proto3" json:"restarted,omitempty"` // true if VPN was restarted
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SaveConfigResponse) Reset() {
	*x = SaveConfigResponse{}
	mi := &file_vpn_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SaveConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SaveConfigResponse) ProtoMessage() {}

func (x *SaveConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SaveConfigResponse.ProtoReflect.Descriptor instead.
func (*SaveConfigResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{28}
}

func (x *SaveConfigResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SaveConfigResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *SaveConfigResponse) GetRestarted() bool {
	if x != nil {
		return x.Restarted
	}
	return false
}

type LogStreamRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinLevel      LogLevel               `protobuf:"varint,1,opt,name=min_level,json=minLevel,proto3,enum=awg.vpn.v1.LogLevel" json:"min_level,omitempty"` // minimum level to stream
	TagFilter     string                 `protobuf:"bytes,2,opt,name=tag_filter,json=tagFilter,proto3" json:"tag_filter,omitempty"`                        // optional: filter by tag
	TailLines     int32                  `protobuf:"varint,3,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`                       // send last N lines first (0 = no history)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogStreamRequest) Reset() {
	*x = LogStreamRequest{}
	mi := &file_vpn_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogStreamRequest) ProtoMessage() {}

func (x *LogStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogStreamRequest.ProtoReflect.Descriptor instead.
func (*LogStreamRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{29}
}

func (x *LogStreamRequest) GetMinLevel() LogLevel {
	if x != nil {
		return x.MinLevel
	}
	return LogLevel_LOG_LEVEL_DEBUG
}

func (x *LogStreamRequest) GetTagFilter() string {
	if x != nil {
		return x.TagFilter
	}
	return ""
}

func (x *LogStreamRequest) GetTailLines() int32 {
	if x != nil {
		return x.TailLines
	}
	return 0
}

type StatsStreamRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IntervalMs    int32                  `protobuf:"varint,1,opt,name=interval_ms,json=intervalMs,proto3" json:"interval_ms,omitempty"` // update interval (default: 1000)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsStreamRequest) Reset() {
	*x = StatsStreamRequest{}
	mi := &file_vpn_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsStreamRequest) ProtoMessage() {}

func (x *StatsStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsStreamRequest.ProtoReflect.Descriptor instead.
func (*StatsStreamRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{30}
}

func (x *StatsStreamRequest) GetIntervalMs() int32 {
	if x != nil {
		return x.IntervalMs
	}
	return 0
}

type ProcessListRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NameFilter    string                 `protobuf:"bytes,1,opt,name=name_filter,json=nameFilter,proto3" json:"name_filter,omitempty"` // optional: filter by name substring
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessListRequest) Reset() {
	*x = ProcessListRequest{}
	mi := &file_vpn_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessListRequest) ProtoMessage() {}

func (x *ProcessListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessListRequest.ProtoReflect.Descriptor instead.
func (*ProcessListRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{31}
}

func (x *ProcessListRequest) GetNameFilter() string {
	if x != nil {
		return x.NameFilter
	}
	return ""
}

type ProcessListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Processes     []*ProcessInfo         `protobuf:"bytes,1,rep,name=processes,proto3" json:"processes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProcessListResponse) Reset() {
	*x = ProcessListResponse{}
	mi := &file_vpn_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessListResponse) ProtoMessage() {}

func (x *ProcessListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessListResponse.ProtoReflect.Descriptor instead.
func (*ProcessListResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{32}
}

func (x *ProcessListResponse) GetProcesses() []*ProcessInfo {
	if x != nil {
		return x.Processes
	}
	return nil
}

type ServiceStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Running       bool                   `protobuf:"varint,1,opt,name=running,proto3" json:"running,omitempty"`
	ActiveTunnels int32                  `protobuf:"varint,2,opt,name=active_tunnels,json=activeTunnels,proto3" json:"active_tunnels,omitempty"`
	TotalTunnels  int32                  `protobuf:"varint,3,opt,name=total_tunnels,json=totalTunnels,proto3" json:"total_tunnels,omitempty"`
	Version       string                 `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	UptimeSeconds int64                  `protobuf:"varint,5,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceStatus) Reset() {
	*x = ServiceStatus{}
	mi := &file_vpn_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceStatus) ProtoMessage() {}

func (x *ServiceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceStatus.ProtoReflect.Descriptor instead.
func (*ServiceStatus) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{33}
}

func (x *ServiceStatus) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *ServiceStatus) GetActiveTunnels() int32 {
	if x != nil {
		return x.ActiveTunnels
	}
	return 0
}

func (x *ServiceStatus) GetTotalTunnels() int32 {
	if x != nil {
		return x.TotalTunnels
	}
	return 0
}

func (x *ServiceStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ServiceStatus) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

type AutostartConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Enabled            bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	RestoreConnections bool                   `protobuf:"varint,2,opt,name=restore_connections,json=restoreConnections,proto3" json:"restore_connections,omitempty"` // auto-connect on startup
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *AutostartConfig) Reset() {
	*x = AutostartConfig{}
	mi := &file_vpn_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutostartConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutostartConfig) ProtoMessage() {}

func (x *AutostartConfig) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutostartConfig.ProtoReflect.Descriptor instead.
func (*AutostartConfig) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{34}
}

func (x *AutostartConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *AutostartConfig) GetRestoreConnections() bool {
	if x != nil {
		return x.RestoreConnections
	}
	return false
}

type SetAutostartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *AutostartConfig       `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAutostartRequest) Reset() {
	*x = SetAutostartRequest{}
	mi := &file_vpn_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAutostartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAutostartRequest) ProtoMessage() {}

func (x *SetAutostartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAutostartRequest.ProtoReflect.Descriptor instead.
func (*SetAutostartRequest) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{35}
}

func (x *SetAutostartRequest) GetConfig() *AutostartConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetAutostartResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAutostartResponse) Reset() {
	*x = SetAutostartResponse{}
	mi := &file_vpn_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAutostartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAutostartResponse) ProtoMessage() {}

func (x *SetAutostartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAutostartResponse.ProtoReflect.Descriptor instead.
func (*SetAutostartResponse) Descriptor() ([]byte, []int) {
	return file_vpn_service_proto_rawDescGZIP(), []int{36}
}

func (x *SetAutostartResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SetAutostartResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_vpn_service_proto protoreflect.FileDescriptor

const file_vpn_service_proto_rawDesc = "" +
	"\n" +
	"\x11vpn_service.proto\x12\n" +
	"awg.vpn.v1\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc0\x02\n" +
	"\fTunnelConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12B\n" +
	"\bsettings\x18\x04 \x03(\v2&.awg.vpn.v1.TunnelConfig.SettingsEntryR\bsettings\x12\x1f\n" +
	"\vallowed_ips\x18\x05 \x03(\tR\n" +
	"allowedIps\x12%\n" +
	"\x0edisallowed_ips\x18\x06 \x03(\tR\rdisallowedIps\x12'\n" +
	"\x0fdisallowed_apps\x18\a \x03(\tR\x0edisallowedApps\x1a;\n" +
	"\rSettingsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb4\x01\n" +
	"\fTunnelStatus\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x120\n" +
	"\x06config\x18\x02 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\x12-\n" +
	"\x05state\x18\x03 \x01(\x0e2\x17.awg.vpn.v1.TunnelStateR\x05state\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"adapter_ip\x18\x05 \x01(\tR\tadapterIp\"u\n" +
	"\x04Rule\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x1b\n" +
	"\ttunnel_id\x18\x02 \x01(\tR\btunnelId\x126\n" +
	"\bfallback\x18\x03 \x01(\x0e2\x1a.awg.vpn.v1.FallbackPolicyR\bfallback\"\x90\x01\n" +
	"\x0eDNSCacheConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x19\n" +
	"\bmax_size\x18\x02 \x01(\x05R\amaxSize\x12\x17\n" +
	"\amin_ttl\x18\x03 \x01(\tR\x06minTtl\x12\x17\n" +
	"\amax_ttl\x18\x04 \x01(\tR\x06maxTtl\x12\x17\n" +
	"\aneg_ttl\x18\x05 \x01(\tR\x06negTtl\"t\n" +
	"\tDNSConfig\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\x12\x18\n" +
	"\aservers\x18\x02 \x03(\tR\aservers\x120\n" +
	"\x05cache\x18\x03 \x01(\v2\x1a.awg.vpn.v1.DNSCacheConfigR\x05cache\"\xaa\x01\n" +
	"\x12GlobalFilterConfig\x12\x1f\n" +
	"\vallowed_ips\x18\x01 \x03(\tR\n" +
	"allowedIps\x12%\n" +
	"\x0edisallowed_ips\x18\x02 \x03(\tR\rdisallowedIps\x12'\n" +
	"\x0fdisallowed_apps\x18\x03 \x03(\tR\x0edisallowedApps\x12#\n" +
	"\rdisable_local\x18\x04 \x01(\bR\fdisableLocal\"\xa7\x01\n" +
	"\tLogConfig\x12\x14\n" +
	"\x05level\x18\x01 \x01(\tR\x05level\x12E\n" +
	"\n" +
	"components\x18\x02 \x03(\v2%.awg.vpn.v1.LogConfig.ComponentsEntryR\n" +
	"components\x1a=\n" +
	"\x0fComponentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf9\x01\n" +
	"\tAppConfig\x126\n" +
	"\x06global\x18\x01 \x01(\v2\x1e.awg.vpn.v1.GlobalFilterConfigR\x06global\x122\n" +
	"\atunnels\x18\x02 \x03(\v2\x18.awg.vpn.v1.TunnelConfigR\atunnels\x12&\n" +
	"\x05rules\x18\x03 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\x12'\n" +
	"\x03dns\x18\x04 \x01(\v2\x15.awg.vpn.v1.DNSConfigR\x03dns\x12/\n" +
	"\alogging\x18\x05 \x01(\v2\x15.awg.vpn.v1.LogConfigR\alogging\"\xc8\x02\n" +
	"\vTunnelStats\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\x12-\n" +
	"\x05state\x18\x02 \x01(\x0e2\x17.awg.vpn.v1.TunnelStateR\x05state\x12\x19\n" +
	"\bbytes_tx\x18\x03 \x01(\x03R\abytesTx\x12\x19\n" +
	"\bbytes_rx\x18\x04 \x01(\x03R\abytesRx\x12\x19\n" +
	"\bspeed_tx\x18\x05 \x01(\x03R\aspeedTx\x12\x19\n" +
	"\bspeed_rx\x18\x06 \x01(\x03R\aspeedRx\x12\x1f\n" +
	"\vpacket_loss\x18\a \x01(\x01R\n" +
	"packetLoss\x12\x1d\n" +
	"\n" +
	"latency_ms\x18\b \x01(\x03R\tlatencyMs\x12A\n" +
	"\x0elast_handshake\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\rlastHandshake\"|\n" +
	"\rStatsSnapshot\x121\n" +
	"\atunnels\x18\x01 \x03(\v2\x17.awg.vpn.v1.TunnelStatsR\atunnels\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"\x9c\x01\n" +
	"\bLogEntry\x128\n" +
	"\ttimestamp\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12*\n" +
	"\x05level\x18\x02 \x01(\x0e2\x14.awg.vpn.v1.LogLevelR\x05level\x12\x10\n" +
	"\x03tag\x18\x03 \x01(\tR\x03tag\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"G\n" +
	"\vProcessInfo\x12\x10\n" +
	"\x03pid\x18\x01 \x01(\rR\x03pid\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\"-\n" +
	"\x0eConnectRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"A\n" +
	"\x0fConnectResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"0\n" +
	"\x11DisconnectRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"D\n" +
	"\x12DisconnectResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"n\n" +
	"\x10AddTunnelRequest\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\x12(\n" +
	"\x10config_file_data\x18\x02 \x01(\fR\x0econfigFileData\"C\n" +
	"\x11AddTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"2\n" +
	"\x13RemoveTunnelRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"F\n" +
	"\x14RemoveTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"G\n" +
	"\x13UpdateTunnelRequest\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.awg.vpn.v1.TunnelConfigR\x06config\"F\n" +
	"\x14UpdateTunnelResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"/\n" +
	"\x10GetTunnelRequest\x12\x1b\n" +
	"\ttunnel_id\x18\x01 \x01(\tR\btunnelId\"H\n" +
	"\x12TunnelListResponse\x122\n" +
	"\atunnels\x18\x01 \x03(\v2\x18.awg.vpn.v1.TunnelStatusR\atunnels\":\n" +
	"\x10RuleListResponse\x12&\n" +
	"\x05rules\x18\x01 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\":\n" +
	"\x10SaveRulesRequest\x12&\n" +
	"\x05rules\x18\x01 \x03(\v2\x10.awg.vpn.v1.RuleR\x05rules\"C\n" +
	"\x11SaveRulesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"t\n" +
	"\x11SaveConfigRequest\x12-\n" +
	"\x06config\x18\x01 \x01(\v2\x15.awg.vpn.v1.AppConfigR\x06config\x120\n" +
	"\x14restart_if_connected\x18\x02 \x01(\bR\x12restartIfConnected\"b\n" +
	"\x12SaveConfigResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1c\n" +
	"\trestarted\x18\x03 \x01(\bR\trestarted\"\x83\x01\n" +
	"\x10LogStreamRequest\x121\n" +
	"\tmin_level\x18\x01 \x01(\x0e2\x14.awg.vpn.v1.LogLevelR\bminLevel\x12\x1d\n" +
	"\n" +
	"tag_filter\x18\x02 \x01(\tR\ttagFilter\x12\x1d\n" +
	"\n" +
	"tail_lines\x18\x03 \x01(\x05R\ttailLines\"5\n" +
	"\x12StatsStreamRequest\x12\x1f\n" +
	"\vinterval_ms\x18\x01 \x01(\x05R\n" +
	"intervalMs\"5\n" +
	"\x12ProcessListRequest\x12\x1f\n" +
	"\vname_filter\x18\x01 \x01(\tR\n" +
	"nameFilter\"L\n" +
	"\x13ProcessListResponse\x125\n" +
	"\tprocesses\x18\x01 \x03(\v2\x17.awg.vpn.v1.ProcessInfoR\tprocesses\"\xb6\x01\n" +
	"\rServiceStatus\x12\x18\n" +
	"\arunning\x18\x01 \x01(\bR\arunning\x12%\n" +
	"\x0eactive_tunnels\x18\x02 \x01(\x05R\ractiveTunnels\x12#\n" +
	"\rtotal_tunnels\x18\x03 \x01(\x05R\ftotalTunnels\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12%\n" +
	"\x0euptime_seconds\x18\x05 \x01(\x03R\ruptimeSeconds\"\\\n" +
	"\x0fAutostartConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12/\n" +
	"\x13restore_connections\x18\x02 \x01(\bR\x12restoreConnections\"J\n" +
	"\x13SetAutostartRequest\x123\n" +
	"\x06config\x18\x01 \x01(\v2\x1b.awg.vpn.v1.AutostartConfigR\x06config\"F\n" +
	"\x14SetAutostartResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error*n\n" +
	"\vTunnelState\x12\x15\n" +
	"\x11TUNNEL_STATE_DOWN\x10\x00\x12\x1b\n" +
	"\x17TUNNEL_STATE_CONNECTING\x10\x01\x12\x13\n" +
	"\x0fTUNNEL_STATE_UP\x10\x02\x12\x16\n" +
	"\x12TUNNEL_STATE_ERROR\x10\x03*R\n" +
	"\x0eFallbackPolicy\x12\x19\n" +
	"\x15FALLBACK_ALLOW_DIRECT\x10\x00\x12\x12\n" +
	"\x0eFALLBACK_BLOCK\x10\x01\x12\x11\n" +
	"\rFALLBACK_DROP\x10\x02*o\n" +
	"\bLogLevel\x12\x13\n" +
	"\x0fLOG_LEVEL_DEBUG\x10\x00\x12\x12\n" +
	"\x0eLOG_LEVEL_INFO\x10\x01\x12\x12\n" +
	"\x0eLOG_LEVEL_WARN\x10\x02\x12\x13\n" +
	"\x0fLOG_LEVEL_ERROR\x10\x03\x12\x11\n" +
	"\rLOG_LEVEL_OFF\x10\x042\xef\n" +
	"\n" +
	"\n" +
	"VPNService\x12>\n" +
	"\tGetStatus\x12\x16.google.protobuf.Empty\x1a\x19.awg.vpn.v1.ServiceStatus\x12:\n" +
	"\bShutdown\x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.Empty\x12E\n" +
	"\vListTunnels\x12\x16.google.protobuf.Empty\x1a\x1e.awg.vpn.v1.TunnelListResponse\x12C\n" +
	"\tGetTunnel\x12\x1c.awg.vpn.v1.GetTunnelRequest\x1a\x18.awg.vpn.v1.TunnelStatus\x12H\n" +
	"\tAddTunnel\x12\x1c.awg.vpn.v1.AddTunnelRequest\x1a\x1d.awg.vpn.v1.AddTunnelResponse\x12Q\n" +
	"\fRemoveTunnel\x12\x1f.awg.vpn.v1.RemoveTunnelRequest\x1a .awg.vpn.v1.RemoveTunnelResponse\x12Q\n" +
	"\fUpdateTunnel\x12\x1f.awg.vpn.v1.UpdateTunnelRequest\x1a .awg.vpn.v1.UpdateTunnelResponse\x12B\n" +
	"\aConnect\x12\x1a.awg.vpn.v1.ConnectRequest\x1a\x1b.awg.vpn.v1.ConnectResponse\x12K\n" +
	"\n" +
	"Disconnect\x12\x1d.awg.vpn.v1.DisconnectRequest\x1a\x1e.awg.vpn.v1.DisconnectResponse\x12H\n" +
	"\rRestartTunnel\x12\x1a.awg.vpn.v1.ConnectRequest\x1a\x1b.awg.vpn.v1.ConnectResponse\x12A\n" +
	"\tListRules\x12\x16.google.protobuf.Empty\x1a\x1c.awg.vpn.v1.RuleListResponse\x12H\n" +
	"\tSaveRules\x12\x1c.awg.vpn.v1.SaveRulesRequest\x1a\x1d.awg.vpn.v1.SaveRulesResponse\x12:\n" +
	"\tGetConfig\x12\x16.google.protobuf.Empty\x1a\x15.awg.vpn.v1.AppConfig\x12K\n" +
	"\n" +
	"SaveConfig\x12\x1d.awg.vpn.v1.SaveConfigRequest\x1a\x1e.awg.vpn.v1.SaveConfigResponse\x12B\n" +
	"\n" +
	"StreamLogs\x12\x1c.awg.vpn.v1.LogStreamRequest\x1a\x14.awg.vpn.v1.LogEntry0\x01\x12J\n" +
	"\vStreamStats\x12\x1e.awg.vpn.v1.StatsStreamRequest\x1a\x19.awg.vpn.v1.StatsSnapshot0\x01\x12P\n" +
	"\rListProcesses\x12\x1e.awg.vpn.v1.ProcessListRequest\x1a\x1f.awg.vpn.v1.ProcessListResponse\x12C\n" +
	"\fGetAutostart\x12\x16.google.protobuf.Empty\x1a\x1b.awg.vpn.v1.AutostartConfig\x12Q\n" +
	"\fSetAutostart\x12\x1f.awg.vpn.v1.SetAutostartRequest\x1a .awg.vpn.v1.SetAutostartResponseB!Z\x1fawg-split-tunnel/api/gen;vpnapib\x06proto3"

var (
	file_vpn_service_proto_rawDescOnce sync.Once
	file_vpn_service_proto_rawDescData []byte
)

func file_vpn_service_proto_rawDescGZIP() []byte {
	file_vpn_service_proto_rawDescOnce.Do(func() {
		file_vpn_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vpn_service_proto_rawDesc), len(file_vpn_service_proto_rawDesc)))
	})
	return file_vpn_service_proto_rawDescData
}

var file_vpn_service_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_vpn_service_proto_msgTypes = make([]protoimpl.MessageInfo, 39)
var file_vpn_service_proto_goTypes = []any{
	(TunnelState)(0),              // 0: awg.vpn.v1.TunnelState
	(FallbackPolicy)(0),           // 1: awg.vpn.v1.FallbackPolicy
	(LogLevel)(0),                 // 2: awg.vpn.v1.LogLevel
	(*TunnelConfig)(nil),          // 3: awg.vpn.v1.TunnelConfig
	(*TunnelStatus)(nil),          // 4: awg.vpn.v1.TunnelStatus
	(*Rule)(nil),                  // 5: awg.vpn.v1.Rule
	(*DNSCacheConfig)(nil),        // 6: awg.vpn.v1.DNSCacheConfig
	(*DNSConfig)(nil),             // 7: awg.vpn.v1.DNSConfig
	(*GlobalFilterConfig)(nil),    // 8: awg.vpn.v1.GlobalFilterConfig
	(*LogConfig)(nil),             // 9: awg.vpn.v1.LogConfig
	(*AppConfig)(nil),             // 10: awg.vpn.v1.AppConfig
	(*TunnelStats)(nil),           // 11: awg.vpn.v1.TunnelStats
	(*StatsSnapshot)(nil),         // 12: awg.vpn.v1.StatsSnapshot
	(*LogEntry)(nil),              // 13: awg.vpn.v1.LogEntry
	(*ProcessInfo)(nil),           // 14: awg.vpn.v1.ProcessInfo
	(*ConnectRequest)(nil),        // 15: awg.vpn.v1.ConnectRequest
	(*ConnectResponse)(nil),       // 16: awg.vpn.v1.ConnectResponse
	(*DisconnectRequest)(nil),     // 17: awg.vpn.v1.DisconnectRequest
	(*DisconnectResponse)(nil),    // 18: awg.vpn.v1.DisconnectResponse
	(*AddTunnelRequest)(nil),      // 19: awg.vpn.v1.AddTunnelRequest
	(*AddTunnelResponse)(nil),     // 20: awg.vpn.v1.AddTunnelResponse
	(*RemoveTunnelRequest)(nil),   // 21: awg.vpn.v1.RemoveTunnelRequest
	(*RemoveTunnelResponse)(nil),  // 22: awg.vpn.v1.RemoveTunnelResponse
	(*UpdateTunnelRequest)(nil),   // 23: awg.vpn.v1.UpdateTunnelRequest
	(*UpdateTunnelResponse)(nil),  // 24: awg.vpn.v1.UpdateTunnelResponse
	(*GetTunnelRequest)(nil),      // 25: awg.vpn.v1.GetTunnelRequest
	(*TunnelListResponse)(nil),    // 26: awg.vpn.v1.TunnelListResponse
	(*RuleListResponse)(nil),      // 27: awg.vpn.v1.RuleListResponse
	(*SaveRulesRequest)(nil),      // 28: awg.vpn.v1.SaveRulesRequest
	(*SaveRulesResponse)(nil),     // 29: awg.vpn.v1.SaveRulesResponse
	(*SaveConfigRequest)(nil),     // 30: awg.vpn.v1.SaveConfigRequest
	(*SaveConfigResponse)(nil),    // 31: awg.vpn.v1.SaveConfigResponse
	(*LogStreamRequest)(nil),      // 32: awg.vpn.v1.LogStreamRequest
	(*StatsStreamRequest)(nil),    // 33: awg.vpn.v1.StatsStreamRequest
	(*ProcessListRequest)(nil),    // 34: awg.vpn.v1.ProcessListRequest
	(*ProcessListResponse)(nil),   // 35: awg.vpn.v1.ProcessListResponse
	(*ServiceStatus)(nil),         // 36: awg.vpn.v1.ServiceStatus
	(*AutostartConfig)(nil),       // 37: awg.vpn.v1.AutostartConfig
	(*SetAutostartRequest)(nil),   // 38: awg.vpn.v1.SetAutostartRequest
	(*SetAutostartResponse)(nil),  // 39: awg.vpn.v1.SetAutostartResponse
	nil,                           // 40: awg.vpn.v1.TunnelConfig.SettingsEntry
	nil,                           // 41: awg.vpn.v1.LogConfig.ComponentsEntry
	(*timestamppb.Timestamp)(nil), // 42: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),         // 43: google.protobuf.Empty
}
var file_vpn_service_proto_depIdxs = []int32{
	40, // 0: awg.vpn.v1.TunnelConfig.settings:type_name -> awg.vpn.v1.TunnelConfig.SettingsEntry
	3,  // 1: awg.vpn.v1.TunnelStatus.config:type_name -> awg.vpn.v1.TunnelConfig
	0,  // 2: awg.vpn.v1.TunnelStatus.state:type_name -> awg.vpn.v1.TunnelState
	1,  // 3: awg.vpn.v1.Rule.fallback:type_name -> awg.vpn.v1.FallbackPolicy
	6,  // 4: awg.vpn.v1.DNSConfig.cache:type_name -> awg.vpn.v1.DNSCacheConfig
	41, // 5: awg.vpn.v1.LogConfig.components:type_name -> awg.vpn.v1.LogConfig.ComponentsEntry
	8,  // 6: awg.vpn.v1.AppConfig.global:type_name -> awg.vpn.v1.GlobalFilterConfig
	3,  // 7: awg.vpn.v1.AppConfig.tunnels:type_name -> awg.vpn.v1.TunnelConfig
	5,  // 8: awg.vpn.v1.AppConfig.rules:type_name -> awg.vpn.v1.Rule
	7,  // 9: awg.vpn.v1.AppConfig.dns:type_name -> awg.vpn.v1.DNSConfig
	9,  // 10: awg.vpn.v1.AppConfig.logging:type_name -> awg.vpn.v1.LogConfig
	0,  // 11: awg.vpn.v1.TunnelStats.state:type_name -> awg.vpn.v1.TunnelState
	42, // 12: awg.vpn.v1.TunnelStats.last_handshake:type_name -> google.protobuf.Timestamp
	11, // 13: awg.vpn.v1.StatsSnapshot.tunnels:type_name -> awg.vpn.v1.TunnelStats
	42, // 14: awg.vpn.v1.StatsSnapshot.timestamp:type_name -> google.protobuf.Timestamp
	42, // 15: awg.vpn.v1.LogEntry.timestamp:type_name -> google.protobuf.Timestamp
	2,  // 16: awg.vpn.v1.LogEntry.level:type_name -> awg.vpn.v1.LogLevel
	3,  // 17: awg.vpn.v1.AddTunnelRequest.config:type_name -> awg.vpn.v1.TunnelConfig
	3,  // 18: awg.vpn.v1.UpdateTunnelRequest.config:type_name -> awg.vpn.v1.TunnelConfig
	4,  // 19: awg.vpn.v1.TunnelListResponse.tunnels:type_name -> awg.vpn.v1.TunnelStatus
	5,  // 20: awg.vpn.v1.RuleListResponse.rules:type_name -> awg.vpn.v1.Rule
	5,  // 21: awg.vpn.v1.SaveRulesRequest.rules:type_name -> awg.vpn.v1.Rule
	10, // 22: awg.vpn.v1.SaveConfigRequest.config:type_name -> awg.vpn.v1.AppConfig
	2,  // 23: awg.vpn.v1.LogStreamRequest.min_level:type_name -> awg.vpn.v1.LogLevel
	14, // 24: awg.vpn.v1.ProcessListResponse.processes:type_name -> awg.vpn.v1.ProcessInfo
	37, // 25: awg.vpn.v1.SetAutostartRequest.config:type_name -> awg.vpn.v1.AutostartConfig
	43, // 26: awg.vpn.v1.VPNService.GetStatus:input_type -> google.protobuf.Empty
	43, // 27: awg.vpn.v1.VPNService.Shutdown:input_type -> google.protobuf.Empty
	43, // 28: awg.vpn.v1.VPNService.ListTunnels:input_type -> google.protobuf.Empty
	25, // 29: awg.vpn.v1.VPNService.GetTunnel:input_type -> awg.vpn.v1.GetTunnelRequest
	19, // 30: awg.vpn.v1.VPNService.AddTunnel:input_type -> awg.vpn.v1.AddTunnelRequest
	21, // 31: awg.vpn.v1.VPNService.RemoveTunnel:input_type -> awg.vpn.v1.RemoveTunnelRequest
	23, // 32: awg.vpn.v1.VPNService.UpdateTunnel:input_type -> awg.vpn.v1.UpdateTunnelRequest
	15, // 33: awg.vpn.v1.VPNService.Connect:input_type -> awg.vpn.v1.ConnectRequest
	17, // 34: awg.vpn.v1.VPNService.Disconnect:input_type -> awg.vpn.v1.DisconnectRequest
	15, // 35: awg.vpn.v1.VPNService.RestartTunnel:input_type -> awg.vpn.v1.ConnectRequest
	43, // 36: awg.vpn.v1.VPNService.ListRules:input_type -> google.protobuf.Empty
	28, // 37: awg.vpn.v1.VPNService.SaveRules:input_type -> awg.vpn.v1.SaveRulesRequest
	43, // 38: awg.vpn.v1.VPNService.GetConfig:input_type -> google.protobuf.Empty
	30, // 39: awg.vpn.v1.VPNService.SaveConfig:input_type -> awg.vpn.v1.SaveConfigRequest
	32, // 40: awg.vpn.v1.VPNService.StreamLogs:input_type -> awg.vpn.v1.LogStreamRequest
	33, // 41: awg.vpn.v1.VPNService.StreamStats:input_type -> awg.vpn.v1.StatsStreamRequest
	34, // 42: awg.vpn.v1.VPNService.ListProcesses:input_type -> awg.vpn.v1.ProcessListRequest
	43, // 43: awg.vpn.v1.VPNService.GetAutostart:input_type -> google.protobuf.Empty
	38, // 44: awg.vpn.v1.VPNService.SetAutostart:input_type -> awg.vpn.v1.SetAutostartRequest
	36, // 45: awg.vpn.v1.VPNService.GetStatus:output_type -> awg.vpn.v1.ServiceStatus
	43, // 46: awg.vpn.v1.VPNService.Shutdown:output_type -> google.protobuf.Empty
	26, // 47: awg.vpn.v1.VPNService.ListTunnels:output_type -> awg.vpn.v1.TunnelListResponse
	4,  // 48: awg.vpn.v1.VPNService.GetTunnel:output_type -> awg.vpn.v1.TunnelStatus
	20, // 49: awg.vpn.v1.VPNService.AddTunnel:output_type -> awg.vpn.v1.AddTunnelResponse
	22, // 50: awg.vpn.v1.VPNService.RemoveTunnel:output_type -> awg.vpn.v1.RemoveTunnelResponse
	24, // 51: awg.vpn.v1.VPNService.UpdateTunnel:output_type -> awg.vpn.v1.UpdateTunnelResponse
	16, // 52: awg.vpn.v1.VPNService.Connect:output_type -> awg.vpn.v1.ConnectResponse
	18, // 53: awg.vpn.v1.VPNService.Disconnect:output_type -> awg.vpn.v1.DisconnectResponse
	16, // 54: awg.vpn.v1.VPNService.RestartTunnel:output_type -> awg.vpn.v1.ConnectResponse
	27, // 55: awg.vpn.v1.VPNService.ListRules:output_type -> awg.vpn.v1.RuleListResponse
	29, // 56: awg.vpn.v1.VPNService.SaveRules:output_type -> awg.vpn.v1.SaveRulesResponse
	10, // 57: awg.vpn.v1.VPNService.GetConfig:output_type -> awg.vpn.v1.AppConfig
	31, // 58: awg.vpn.v1.VPNService.SaveConfig:output_type -> awg.vpn.v1.SaveConfigResponse
	13, // 59: awg.vpn.v1.VPNService.StreamLogs:output_type -> awg.vpn.v1.LogEntry
	12, // 60: awg.vpn.v1.VPNService.StreamStats:output_type -> awg.vpn.v1.StatsSnapshot
	35, // 61: awg.vpn.v1.VPNService.ListProcesses:output_type -> awg.vpn.v1.ProcessListResponse
	37, // 62: awg.vpn.v1.VPNService.GetAutostart:output_type -> awg.vpn.v1.AutostartConfig
	39, // 63: awg.vpn.v1.VPNService.SetAutostart:output_type -> awg.vpn.v1.SetAutostartResponse
	45, // [45:64] is the sub-list for method output_type
	26, // [26:45] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_vpn_service_proto_init() }
func file_vpn_service_proto_init() {
	if File_vpn_service_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vpn_service_proto_rawDesc), len(file_vpn_service_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   39,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_vpn_service_proto_goTypes,
		DependencyIndexes: file_vpn_service_proto_depIdxs,
		EnumInfos:         file_vpn_service_proto_enumTypes,
		MessageInfos:      file_vpn_service_proto_msgTypes,
	}.Build()
	File_vpn_service_proto = out.File
	file_vpn_service_proto_goTypes = nil
	file_vpn_service_proto_depIdxs = nil
}
