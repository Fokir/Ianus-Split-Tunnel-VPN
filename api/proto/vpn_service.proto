syntax = "proto3";

package awg.vpn.v1;

option go_package = "awg-split-tunnel/api/gen;vpnapi";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// ─── Enums ──────────────────────────────────────────────────────────

enum TunnelState {
  TUNNEL_STATE_DOWN = 0;
  TUNNEL_STATE_CONNECTING = 1;
  TUNNEL_STATE_UP = 2;
  TUNNEL_STATE_ERROR = 3;
}

enum FallbackPolicy {
  FALLBACK_ALLOW_DIRECT = 0;
  FALLBACK_BLOCK = 1;
  FALLBACK_DROP = 2;
  FALLBACK_FAILOVER = 3;
}

enum LogLevel {
  LOG_LEVEL_DEBUG = 0;
  LOG_LEVEL_INFO = 1;
  LOG_LEVEL_WARN = 2;
  LOG_LEVEL_ERROR = 3;
  LOG_LEVEL_OFF = 4;
}

enum DaemonState {
  DAEMON_STATE_IDLE = 0;
  DAEMON_STATE_ACTIVATING = 1;
  DAEMON_STATE_ACTIVE = 2;
  DAEMON_STATE_DEACTIVATING = 3;
}

// ─── Tunnel messages ────────────────────────────────────────────────

message TunnelConfig {
  string id = 1;
  string protocol = 2;
  string name = 3;
  map<string, string> settings = 4;
  repeated string allowed_ips = 5;
  repeated string disallowed_ips = 6;
  repeated string disallowed_apps = 7;
  int32 sort_index = 8;             // user-defined display order
}

message TunnelStatus {
  string id = 1;
  TunnelConfig config = 2;
  TunnelState state = 3;
  string error = 4;          // error message if state == ERROR
  string adapter_ip = 5;     // VPN adapter IP (e.g. "10.8.1.2")
  string external_ip = 6;    // VPN server endpoint IP
  string country_code = 7;   // 2-letter country code from geoip
  int32 sort_index = 8;      // user-defined display order
}

// ─── Domain rule messages ───────────────────────────────────────────

enum DomainAction {
  DOMAIN_ACTION_ROUTE = 0;
  DOMAIN_ACTION_DIRECT = 1;
  DOMAIN_ACTION_BLOCK = 2;
}

message DomainRule {
  string pattern = 1;           // "domain:vk.com", "full:example.com", "keyword:google", "geosite:ru"
  string tunnel_id = 2;         // only for DOMAIN_ACTION_ROUTE
  DomainAction action = 3;
  bool active = 4;              // tunnel is connected (for UI display)
}

// ─── Rule messages ──────────────────────────────────────────────────

message Rule {
  string pattern = 1;
  string tunnel_id = 2;       // empty for drop-only rules
  FallbackPolicy fallback = 3;
  string priority = 4;         // "auto", "realtime", "normal", "low"
  bool active = 5;             // tunnel is connected, rule is active
}

// ─── DNS config ─────────────────────────────────────────────────────

message DNSCacheConfig {
  bool enabled = 1;
  int32 max_size = 2;
  string min_ttl = 3;         // duration string, e.g. "30s"
  string max_ttl = 4;         // duration string, e.g. "5m"
  string neg_ttl = 5;         // duration string, e.g. "60s"
}

message FakeIPConfig {
  bool enabled = 1;
  string cidr = 2;                   // default "198.18.0.0/15"
}

message DNSConfig {
  string tunnel_id = 1;              // deprecated: use tunnel_ids
  repeated string servers = 2;
  DNSCacheConfig cache = 3;
  repeated string tunnel_ids = 4;    // tunnels for parallel DNS resolution
  FakeIPConfig fakeip = 5;
}

// ─── Global filter config ───────────────────────────────────────────

message GlobalFilterConfig {
  repeated string allowed_ips = 1;
  repeated string disallowed_ips = 2;
  repeated string disallowed_apps = 3;
  bool disable_local = 4;
}

// ─── Logging config ─────────────────────────────────────────────────

message LogConfig {
  string level = 1;           // "debug", "info", "warn", "error", "off"
  map<string, string> components = 2;  // per-component overrides
  bool file_logging_enabled = 3;      // write logs to file (default: true)
}

// ─── Subscription config ───────────────────────────────────────────

message SubscriptionConfig {
  string name = 1;              // unique subscription name
  string url = 2;               // subscription URL
  string refresh_interval = 3;  // e.g. "6h", "24h"
  string user_agent = 4;        // custom User-Agent header
  string prefix = 5;            // prefix for generated tunnel IDs
}

message SubscriptionStatus {
  SubscriptionConfig config = 1;
  int32 tunnel_count = 2;       // number of tunnels fetched
  string last_error = 3;        // last error message (empty if OK)
}

// ─── Full config ────────────────────────────────────────────────────

message ReconnectConfig {
  bool enabled = 1;
  string interval = 2;      // duration string, e.g. "5s"
  int32 max_retries = 3;    // 0 = unlimited
}

message AppConfig {
  GlobalFilterConfig global = 1;
  repeated TunnelConfig tunnels = 2;
  repeated Rule rules = 3;
  DNSConfig dns = 4;
  LogConfig logging = 5;
  repeated DomainRule domain_rules = 6;
  repeated SubscriptionConfig subscriptions = 7;
  ReconnectConfig reconnect = 8;
}

// ─── Stats messages ─────────────────────────────────────────────────

message TunnelStats {
  string tunnel_id = 1;
  TunnelState state = 2;
  int64 bytes_tx = 3;         // total bytes sent
  int64 bytes_rx = 4;         // total bytes received
  int64 speed_tx = 5;         // bytes/sec upload
  int64 speed_rx = 6;         // bytes/sec download
  double packet_loss = 7;     // 0.0-1.0, fraction of lost packets
  int64 latency_ms = 8;       // RTT in milliseconds
  google.protobuf.Timestamp last_handshake = 9;
  int64 jitter_ms = 10;       // max-min RTT in milliseconds (1-min window)
}

message StatsSnapshot {
  repeated TunnelStats tunnels = 1;
  google.protobuf.Timestamp timestamp = 2;
}

// ─── Log messages ───────────────────────────────────────────────────

message LogEntry {
  google.protobuf.Timestamp timestamp = 1;
  LogLevel level = 2;
  string tag = 3;             // "[Core]", "[Gateway]", etc.
  string message = 4;
}

// ─── Process messages ───────────────────────────────────────────────

message ProcessInfo {
  uint32 pid = 1;
  string name = 2;            // exe file name
  string path = 3;            // full exe path
}

// ─── Request / Response messages ────────────────────────────────────

// -- Tunnel management --

message ConnectRequest {
  string tunnel_id = 1;       // specific tunnel, or empty for all
}

message ConnectResponse {
  bool success = 1;
  string error = 2;
}

message DisconnectRequest {
  string tunnel_id = 1;       // specific tunnel, or empty for all
}

message DisconnectResponse {
  bool success = 1;
  string error = 2;
}

message AddTunnelRequest {
  TunnelConfig config = 1;
  bytes config_file_data = 2; // raw .conf file content (for AWG)
}

message AddTunnelResponse {
  bool success = 1;
  string error = 2;
}

message RemoveTunnelRequest {
  string tunnel_id = 1;
}

message RemoveTunnelResponse {
  bool success = 1;
  string error = 2;
}

message UpdateTunnelRequest {
  TunnelConfig config = 1;
}

message UpdateTunnelResponse {
  bool success = 1;
  string error = 2;
}

message GetTunnelRequest {
  string tunnel_id = 1;
}

message TunnelListResponse {
  repeated TunnelStatus tunnels = 1;
}

message SaveTunnelOrderRequest {
  repeated string tunnel_ids = 1;
}

message SaveTunnelOrderResponse {
  bool success = 1;
  string error = 2;
}

// -- Rules --

message RuleListResponse {
  repeated Rule rules = 1;
}

message SaveRulesRequest {
  repeated Rule rules = 1;
}

message SaveRulesResponse {
  bool success = 1;
  string error = 2;
}

// -- Domain rules --

message DomainRuleListResponse {
  repeated DomainRule rules = 1;
}

message SaveDomainRulesRequest {
  repeated DomainRule rules = 1;
}

message SaveDomainRulesResponse {
  bool success = 1;
  string error = 2;
}

message GeositeCategoriesResponse {
  repeated string categories = 1;
}

message UpdateGeositeResponse {
  bool success = 1;
  string error = 2;
}

// -- Config --

message SaveConfigRequest {
  AppConfig config = 1;
  bool restart_if_connected = 2;
}

message SaveConfigResponse {
  bool success = 1;
  string error = 2;
  bool restarted = 3;         // true if VPN was restarted
}

// -- Logs --

message LogStreamRequest {
  LogLevel min_level = 1;     // minimum level to stream
  string tag_filter = 2;      // optional: filter by tag
  int32 tail_lines = 3;       // send last N lines first (0 = no history)
}

// -- Stats --

message StatsStreamRequest {
  int32 interval_ms = 1;      // update interval (default: 1000)
}

// -- Process listing --

message ProcessListRequest {
  string name_filter = 1;     // optional: filter by name substring
}

message ProcessListResponse {
  repeated ProcessInfo processes = 1;
}

// -- Subscriptions --

message SubscriptionListResponse {
  repeated SubscriptionStatus subscriptions = 1;
}

message AddSubscriptionRequest {
  SubscriptionConfig config = 1;
}

message AddSubscriptionResponse {
  bool success = 1;
  string error = 2;
  int32 tunnel_count = 3;       // number of tunnels fetched on initial refresh
}

message RemoveSubscriptionRequest {
  string name = 1;
}

message RemoveSubscriptionResponse {
  bool success = 1;
  string error = 2;
}

message RefreshSubscriptionRequest {
  string name = 1;              // specific subscription, or empty for all
}

message RefreshSubscriptionResponse {
  bool success = 1;
  string error = 2;
  int32 tunnel_count = 3;
}

message UpdateSubscriptionRequest {
  SubscriptionConfig config = 1;    // name must match existing subscription
}

message UpdateSubscriptionResponse {
  bool success = 1;
  string error = 2;
}

message RenameTunnelRequest {
  string tunnel_id = 1;
  string name = 2;                  // new display name
}

message RenameTunnelResponse {
  bool success = 1;
  string error = 2;
}

// -- Service status --

message ServiceStatus {
  bool running = 1;
  int32 active_tunnels = 2;
  int32 total_tunnels = 3;
  string version = 4;
  int64 uptime_seconds = 5;
  DaemonState daemon_state = 6;
}

// -- Daemon lifecycle (macOS socket activation) --

message ActivateRequest {}
message ActivateResponse {
  bool success = 1;
  string error = 2;
}

message DeactivateRequest {}
message DeactivateResponse {
  bool success = 1;
  string error = 2;
}

// -- Update --

message UpdateInfo {
  string version = 1;           // new version string (e.g. "1.2.0")
  string release_notes = 2;     // markdown release notes
  string asset_url = 3;         // download URL
  int64 asset_size = 4;         // asset size in bytes
}

message CheckUpdateResponse {
  bool available = 1;
  UpdateInfo info = 2;
}

message ApplyUpdateResponse {
  bool success = 1;
  string error = 2;
}

// -- Autostart --

message AutostartConfig {
  bool enabled = 1;
  bool restore_connections = 2;  // auto-connect on startup
  string gui_exe_path = 3;       // path to GUI executable (for scheduled task creation)
}

message SetAutostartRequest {
  AutostartConfig config = 1;
}

message SetAutostartResponse {
  bool success = 1;
  string error = 2;
}

// ─── Conflicting services ──────────────────────────────────────────

message ConflictingService {
  string name = 1;             // service or process name
  string display_name = 2;     // human-readable name
  string type = 3;             // "service" or "process"
  bool running = 4;            // true if currently active
  string description = 5;      // why it conflicts
}

message ConflictingServicesResponse {
  repeated ConflictingService services = 1;
}

message StopConflictingServicesRequest {
  repeated string names = 1;   // service/process names to stop
}

message StopConflictingServicesResponse {
  bool success = 1;
  string error = 2;
  repeated string stopped = 3;   // successfully stopped
  repeated string failed = 4;    // failed to stop
}

// ─── Service definition ─────────────────────────────────────────────

service VPNService {
  // -- Service lifecycle --
  rpc GetStatus(google.protobuf.Empty) returns (ServiceStatus);
  rpc Shutdown(google.protobuf.Empty) returns (google.protobuf.Empty);

  // -- Daemon lifecycle (macOS socket activation) --
  rpc Activate(ActivateRequest) returns (ActivateResponse);
  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse);

  // -- Tunnel management --
  rpc ListTunnels(google.protobuf.Empty) returns (TunnelListResponse);
  rpc GetTunnel(GetTunnelRequest) returns (TunnelStatus);
  rpc AddTunnel(AddTunnelRequest) returns (AddTunnelResponse);
  rpc RemoveTunnel(RemoveTunnelRequest) returns (RemoveTunnelResponse);
  rpc UpdateTunnel(UpdateTunnelRequest) returns (UpdateTunnelResponse);
  rpc Connect(ConnectRequest) returns (ConnectResponse);
  rpc Disconnect(DisconnectRequest) returns (DisconnectResponse);
  rpc RestartTunnel(ConnectRequest) returns (ConnectResponse);
  rpc SaveTunnelOrder(SaveTunnelOrderRequest) returns (SaveTunnelOrderResponse);
  rpc RenameTunnel(RenameTunnelRequest) returns (RenameTunnelResponse);

  // -- Rules --
  rpc ListRules(google.protobuf.Empty) returns (RuleListResponse);
  rpc SaveRules(SaveRulesRequest) returns (SaveRulesResponse);

  // -- Domain rules --
  rpc ListDomainRules(google.protobuf.Empty) returns (DomainRuleListResponse);
  rpc SaveDomainRules(SaveDomainRulesRequest) returns (SaveDomainRulesResponse);
  rpc ListGeositeCategories(google.protobuf.Empty) returns (GeositeCategoriesResponse);
  rpc ListGeoIPCategories(google.protobuf.Empty) returns (GeositeCategoriesResponse);
  rpc UpdateGeosite(google.protobuf.Empty) returns (UpdateGeositeResponse);

  // -- Config --
  rpc GetConfig(google.protobuf.Empty) returns (AppConfig);
  rpc SaveConfig(SaveConfigRequest) returns (SaveConfigResponse);

  // -- Streaming --
  rpc StreamLogs(LogStreamRequest) returns (stream LogEntry);
  rpc StreamStats(StatsStreamRequest) returns (stream StatsSnapshot);

  // -- Processes --
  rpc ListProcesses(ProcessListRequest) returns (ProcessListResponse);

  // -- Autostart --
  rpc GetAutostart(google.protobuf.Empty) returns (AutostartConfig);
  rpc SetAutostart(SetAutostartRequest) returns (SetAutostartResponse);

  // -- Subscriptions --
  rpc ListSubscriptions(google.protobuf.Empty) returns (SubscriptionListResponse);
  rpc AddSubscription(AddSubscriptionRequest) returns (AddSubscriptionResponse);
  rpc RemoveSubscription(RemoveSubscriptionRequest) returns (RemoveSubscriptionResponse);
  rpc RefreshSubscription(RefreshSubscriptionRequest) returns (RefreshSubscriptionResponse);
  rpc UpdateSubscription(UpdateSubscriptionRequest) returns (UpdateSubscriptionResponse);

  // -- Connection restore --
  rpc RestoreConnections(google.protobuf.Empty) returns (ConnectResponse);

  // -- DNS --
  rpc FlushDNS(google.protobuf.Empty) returns (ConnectResponse);

  // -- Updates --
  rpc CheckUpdate(google.protobuf.Empty) returns (CheckUpdateResponse);
  rpc ApplyUpdate(google.protobuf.Empty) returns (ApplyUpdateResponse);

  // -- Conflicting services --
  rpc CheckConflictingServices(google.protobuf.Empty) returns (ConflictingServicesResponse);
  rpc StopConflictingServices(StopConflictingServicesRequest) returns (StopConflictingServicesResponse);

}
